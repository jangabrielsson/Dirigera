{"apiVersion":"1.3","files":[{"isOpen":false,"isMain":false,"content":"--------------------------------------------------------------------------------------------------------------------------\n-- sha2 lib v0.1 (c) tinman\/Intuitech\n-- 99.99987534 % of the code is based on sha2.lua from Egor Skriptunoff\n-- I removed everything not really HC3 related to simplify the code, added examples etc.\n--------------------------------------------------------------------------------------------------------------------------\n--\n-- DESCRIPTION:\n--    This module contains functions to calculate SHA digest:\n--       MD5, SHA-1,\n--       SHA-224, SHA-256, SHA-512\/224, SHA-512\/256, SHA-384, SHA-512,\n--       SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,\n--       HMAC\n--    Written in pure Lua.\n--\n-- USAGE:\n--    Input data should be provided as a binary string: either as a whole string or as a sequence of substrings (chunk-by-chunk loading, total length < 9*10^15 bytes).\n--    Result (SHA digest) is returned in hexadecimal representation as a string of lowercase hex digits.\n--    Simplest usage example:\n--       local your_hash = sha.sha256(\"your string\")\n--\n-- FAQ:\n--\n--    **Q:** How to get SHA digest as binary string instead of hexadecimal representation?\n--    **A:**  \n--    Use function sha.hex2bin() to convert hexadecimal to binary:\n--    local binary_hash = sha.hex2bin(sha.sha256(\"your string\"))\n--    assert(binary_hash == \"\\209Mi\\29\\172p\\234\\218\\20\\217\\242>\\248\\0\\145\\188\\161\\199\\\\\\247|\\241\\205\\\\\\242\\208A\\128\\202\\r\\153\\17\")\n--\n--    **Q:** How to get SHA digest as base64 string?\n--    **A:**  \n--    There are functions sha.bin2base64() and sha.base642bin() for converting between binary and base64:\n--    local binary_hash = sha.hex2bin(sha.sha256(\"your string\"))\n--    local base64_hash = sha.bin2base64(binary_hash)\n--    assert(base64_hash == \"0U1pHaxw6toU2fI++ACRvKHHXPd88c1c8tBBgMoNmRE=\")\n--\n--    **Q:** How to calculate SHA digest of long data stream?\n--    **A:**\n--    local append = sha.sha256()  -- if the \"message\" argument is omitted then \"append\" function is returned\n--    append(\"your\")\n--    append(\" st\")                -- you should pass all parts of your long message to the \"append\" function (chunk-by-chunk)\n--    append(\"ring\")\n--    local your_hash = append()   -- and finally ask for the result (by invoking the \"append\" function without argument)\n--    assert(your_hash == \"d14d691dac70eada14d9f23ef80091bca1c75cf77cf1cd5cf2d04180ca0d9911\")\n--\n--    **Q:** How to calculate HMAC-SHA1, HMAC-SHA256, etc. ?\n--    **A:** Calculating HMAC-SHA1\n--    local your_hmac = sha.hmac(sha.sha1, \"your key\", \"your message\")\n--    assert(your_hmac == \"317d0dfd868a5c06c9444ac1328aa3e2bfd29fb2\")\n--    \n--    The same in chunk-by-chunk mode (for long messages):\n--    local append = sha.hmac(sha.sha1, \"your key\")\n--    append(\"your\")\n--    append(\" mess\")\n--    append(\"age\")\n--    local your_hmac = append()\n--    assert(your_hmac == \"317d0dfd868a5c06c9444ac1328aa3e2bfd29fb2\")\n--\n--    **Q:** Can SHAKE128\/SHAKE256 be used to generate digest of infinite length ?\n--    **A:** Yes!  \n--    For example, you can convert your password into infinite stream of pseudo-random bytes.  \n--    Set `digest_size_in_bytes` to `-1` and obtain the function `get_next_part(part_size_in_bytes)`.  \n--    Invoke this function repeatedly to get consecutive parts of the infinite digest.\n--    local get_next_part_of_digest = sha.shake128(-1, \"The quick brown fox jumps over the lazy dog\")\n--    assert(get_next_part_of_digest(5) == \"f4202e3c58\") -- 5 bytes in hexadecimal representation\n--    assert(get_next_part_of_digest()  == \"52\")         -- size=1 is assumed when omitted\n--    assert(get_next_part_of_digest(0) == \"\")           -- size=0 is a valid size\n--    assert(get_next_part_of_digest(4) == \"f9182a04\")   -- and so on to the infinity...\n--    Note: you can use sha.hex2bin() to convert these hexadecimal parts to binary strings\n--    By definition, the result of SHAKE with finite \"digest_size_in_bytes\" is just a finite prefix of \"infinite digest\":\n--    assert(sha.shake128(4, \"The quick brown fox jumps over the lazy dog\")) == \"f4202e3c\")\n--    \n--    For SHAKE, it's possible to combine \"chunk-by-chunk\" input mode with \"chunk-by-chunk\" output mode:\n--    local append_input_message = sha.shake128(-1)\n--    append_input_message(\"The quick brown fox\")\n--    append_input_message(\" jumps over\")\n--    append_input_message(\" the lazy dog\")\n--    local get_next_part_of_digest = append_input_message()  -- input stream is terminated, now we can start receiving the output stream\n--    assert(get_next_part_of_digest(5) == \"f4202e3c58\")\n--    assert(get_next_part_of_digest(5) == \"52f9182a04\")      \n--    \n-- and so on...\n--\n-----------------------------------------------------------------------------\n\nlocal print_debug_messages = false  -- set to true to view some messages about your system's abilities and implementation branch chosen for your system\n\nlocal unpack, table_concat, byte, char, string_rep, sub, gsub, gmatch, string_format, floor, ceil, math_min, math_max, tonumber, type =\n   table.unpack or unpack, table.concat, string.byte, string.char, string.rep, string.sub, string.gsub, string.gmatch, \n   string.format, math.floor, math.ceil, math.min, math.max, tonumber, type\n\nlocal function get_precision(one)\n   -- \"one\" must be either float 1.0 or integer 1\n   -- returns bits_precision, is_integer\n   -- This function works correctly with all floating point datatypes (including non-IEEE-754)\n   local k, n, m, prev_n = 0, one, one\n   while true do\n      k, prev_n, n, m = k + 1, n, n + n + 1, m + m + k % 2\n      if k > 256 or n - (n - 1) ~= 1 or m - (m - 1) ~= 1 or n == m then\n         return k, false   -- floating point datatype\n      elseif n == prev_n then\n         return k, true    -- integer datatype\n      end\n   end\nend\n\n-- Make sure Lua has \"double\" numbers\nlocal x = 2\/3\nlocal Lua_has_double = x * 5 > 3 and x * 4 < 3 and get_precision(1.0) >= 53\nassert(Lua_has_double, \"at least 53-bit floating point numbers are required\")\n\nlocal int_prec, Lua_has_integers = get_precision(1)\nlocal Lua_has_int64 = Lua_has_integers and int_prec == 64\nlocal Lua_has_int32 = Lua_has_integers and int_prec == 32\nassert(Lua_has_int64 or Lua_has_int32 or not Lua_has_integers, \"Lua integers must be either 32-bit or 64-bit\")\n\nlocal b\nlocal library_name\n-- For vanilla Lua, \"bit\"\/\"bit32\" libraries are searched in global namespace only.  No attempt is made to load a library if it's not loaded yet.\nfor _, libname in ipairs(_VERSION == \"Lua 5.3\" and {\"bit32\", \"bit\"} or {\"bit\", \"bit32\"}) do\n      if type(_G[libname]) == \"table\" and _G[libname].bxor then\n         b = _G[libname]\n         library_name = libname\n         break\n      end\nend\n \n--------------------------------------------------------------------------------\n--\n--\tHashing speed (Bytes per Second) on Fibaro HC3\t\t\n--\t            INT64\t        LIB32\t        bit lib emulation\t\n-- MD5\t        1.007*10^6\t    4.580*10^5\t    0.881*10^5\t\n-- SHA1\t        4.879*10^5\t    2.331*10^5\t    3.531*10^4\t\n-- SHA256\t    3.702*10^5\t    1.057*10^5\t    1.522*10^4\t\n-- SHA512\t    0.501*10^6\t    0.503*10^5\t    1.043*10^4\t\n-- SHA512-256\t0.501*10^6\t    0.500*10^5\t    1.042*10^4\t\n-- SHA3-256\t    0.581*10^6\t    4.698*10^4\t    0.618*10^4\t\n-- SHA3-512\t    3.155*10^5\t    2.515*10^4\t    3.272*10^3\n--\n-- You can disable here some of your system's abilities (for testing purposes)\n-- if both uncommented bit lib emulation will be used.\n-- Lua_has_int64   = nil -- uncomment this to disable INT64\nb, library_name = nil -- yes, HC3 can INT64 so let's disable LIB32. In case of issues comment it out.\n--------------------------------------------------------------------------------\n\n-- Selecting the most suitable implementation for given set of abilities\nlocal method, branch\nif Lua_has_int64 then\n   method = \"Using native int64 bitwise operators\"\n   branch = \"INT64\"\nelseif library_name then   -- when bitwise library is available (Lua 5.2 with native library \"bit32\" or Lua 5.1 with external library \"bit\")\n   method = \"Using '\"..library_name..\"' library\"\n   branch = \"LIB32\"\nelse\n   method = \"Emulating bitwise operators using look-up table\"\n   branch = \"EMUL\"\nend\n\nif print_debug_messages then\n   -- Printing the implementation selected to be used on your system\n   print(\"Implementation selected:\")\n   print(\"   \"..method)\nend\n\n\n--------------------------------------------------------------------------------\n-- BASIC 32-BIT BITWISE FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal AND, OR, XOR, SHL, SHR, ROL, ROR, NOT, NORM, HEX, XOR_BYTE\n-- Only low 32 bits of function arguments matter, high bits are ignored\n-- The result of all functions (except HEX) is an integer inside \"correct range\":\n--    for \"bit\" library:    (-2^31)..(2^31-1)\n--    for \"bit32\" library:        0..(2^32-1)\n\nif branch == \"LIB32\" then\n   -- Your system has 32-bit bitwise library (either \"bit\" or \"bit32\")\n\n   AND  = b.band                -- 2 arguments\n   OR   = b.bor                 -- 2 arguments\n   XOR  = b.bxor                -- 2..5 arguments\n   SHL  = b.lshift              -- second argument is integer 0..31\n   SHR  = b.rshift              -- second argument is integer 0..31\n   ROL  = b.rol or b.lrotate    -- second argument is integer 0..31\n   ROR  = b.ror or b.rrotate    -- second argument is integer 0..31\n   NOT  = b.bnot                -- only for LuaJIT\n   NORM = b.tobit               -- only for LuaJIT\n   HEX  = b.tohex               -- returns string of 8 lowercase hexadecimal digits\n   assert(AND and OR and XOR and SHL and SHR and ROL and ROR and NOT, \"Library '\"..library_name..\"' is incomplete\")\n   XOR_BYTE = XOR               -- XOR of two bytes (0..255)\n\nelseif branch == \"EMUL\" then\n   -- Emulating 32-bit bitwise operations using 53-bit floating point arithmetic\n\n   function SHL(x, n)\n      return (x * 2^n) % 2^32\n   end\n\n   function SHR(x, n)\n      -- return (x % 2^32 - x % 2^n) \/ 2^n\n      x = x % 2^32 \/ 2^n\n      return x - x % 1\n   end\n\n   function ROL(x, n)\n      x = x % 2^32 * 2^n\n      local r = x % 2^32\n      return r + (x - r) \/ 2^32\n   end\n\n   function ROR(x, n)\n      x = x % 2^32 \/ 2^n\n      local r = x % 1\n      return r * 2^32 + (x - r)\n   end\n\n   local AND_of_two_bytes = {[0] = 0}  -- look-up table (256*256 entries)\n   local idx = 0\n   for y = 0, 127 * 256, 256 do\n      for x = y, y + 127 do\n         x = AND_of_two_bytes[x] * 2\n         AND_of_two_bytes[idx] = x\n         AND_of_two_bytes[idx + 1] = x\n         AND_of_two_bytes[idx + 256] = x\n         AND_of_two_bytes[idx + 257] = x + 1\n         idx = idx + 2\n      end\n      idx = idx + 256\n   end\n\n   local function and_or_xor(x, y, operation)\n      -- operation: nil = AND, 1 = OR, 2 = XOR\n      local x0 = x % 2^32\n      local y0 = y % 2^32\n      local rx = x0 % 256\n      local ry = y0 % 256\n      local res = AND_of_two_bytes[rx + ry * 256]\n      x = x0 - rx\n      y = (y0 - ry) \/ 256\n      rx = x % 65536\n      ry = y % 256\n      res = res + AND_of_two_bytes[rx + ry] * 256\n      x = (x - rx) \/ 256\n      y = (y - ry) \/ 256\n      rx = x % 65536 + y % 256\n      res = res + AND_of_two_bytes[rx] * 65536\n      res = res + AND_of_two_bytes[(x + y - rx) \/ 256] * 16777216\n      if operation then\n         res = x0 + y0 - operation * res\n      end\n      return res\n   end\n\n   function AND(x, y)\n      return and_or_xor(x, y)\n   end\n\n   function OR(x, y)\n      return and_or_xor(x, y, 1)\n   end\n\n   function XOR(x, y, z, t, u)          -- 2..5 arguments\n      if z then\n         if t then\n            if u then\n               t = and_or_xor(t, u, 2)\n            end\n            z = and_or_xor(z, t, 2)\n         end\n         y = and_or_xor(y, z, 2)\n      end\n      return and_or_xor(x, y, 2)\n   end\n\n   function XOR_BYTE(x, y)\n      return x + y - 2 * AND_of_two_bytes[x + y * 256]\n   end\n\nend\n\nHEX = HEX\n   or\n      pcall(string_format, \"%x\", 2^31) and\n      function (x)  -- returns string of 8 lowercase hexadecimal digits\n         return string_format(\"%08x\", x % 4294967296)\n      end\n   or\n      function (x)  -- for OpenWrt's dialect of Lua\n         return string_format(\"%08x\", (x + 2^31) % 2^32 - 2^31)\n      end\n\nlocal function XOR32A5(x)\n   return XOR(x, 0xA5A5A5A5) % 4294967296\nend\n\nlocal function create_array_of_lanes()\n   return {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nend\n\n--------------------------------------------------------------------------------\n-- CREATING OPTIMIZED INNER LOOP\n--------------------------------------------------------------------------------\n\n-- Inner loop functions\nlocal sha256_feed_64, sha512_feed_128, md5_feed_64, sha1_feed_64, keccak_feed\n\n-- Arrays of SHA2 \"magic numbers\" (in \"INT64\" and \"FFI\" branches \"*_lo\" arrays contain 64-bit values)\nlocal sha2_K_lo, sha2_K_hi, sha2_H_lo, sha2_H_hi, sha3_RC_lo, sha3_RC_hi = {}, {}, {}, {}, {}, {}\nlocal sha2_H_ext256 = {[224] = {}, [256] = sha2_H_hi}\nlocal sha2_H_ext512_lo, sha2_H_ext512_hi = {[384] = {}, [512] = sha2_H_lo}, {[384] = {}, [512] = sha2_H_hi}\nlocal md5_K, md5_sha1_H = {}, {0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0}\nlocal md5_next_shift = {0, 0, 0, 0, 0, 0, 0, 0, 28, 25, 26, 27, 0, 0, 10, 9, 11, 12, 0, 15, 16, 17, 18, 0, 20, 22, 23, 21}\nlocal HEX64, XOR64A5, lanes_index_base  -- defined only for branches that internally use 64-bit integers: \"INT64\" and \"FFI\"\nlocal common_W = {}    -- temporary table shared between all calculations (to avoid creating new temporary table every time)\nlocal K_lo_modulo, hi_factor, hi_factor_keccak = 4294967296, 0, 0\n\nlocal function build_keccak_format(elem)\n   local keccak_format = {}\n   for _, size in ipairs{1, 9, 13, 17, 18, 21} do\n      keccak_format[size] = \"<\"..string_rep(elem, size)\n   end\n   return keccak_format\nend\n\nif branch == \"INT64\" then\n\n   -- implementation for Lua 5.3\/5.4\n\n   hi_factor = 4294967296\n   hi_factor_keccak = 4294967296\n   lanes_index_base = 1\n\n      local string_format, string_unpack = string.format, string.unpack\n\n      function HEX64(x)\n         return string_format(\"%016x\", x)\n      end\n\n      function XOR64A5(x)\n         return x ~ 0xa5a5a5a5a5a5a5a5\n      end\n\n      function XOR_BYTE(x, y)\n         return x ~ y\n      end\n\n      local common_W = {}\n\n      function sha256_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K = common_W, sha2_K_hi\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 64 do\n               local a = W[j-15]\n               a = a<<32 | a\n               local b = W[j-2]\n               b = b<<32 | b\n               W[j] = (a>>7 ~ a>>18 ~ a>>35) + (b>>17 ~ b>>19 ~ b>>42) + W[j-7] + W[j-16] & (1<<32)-1\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 64 do\n               e = e<<32 | e & (1<<32)-1\n               local z = (e>>6 ~ e>>11 ~ e>>25) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = a<<32 | a & (1<<32)-1\n               a = z + ((a ~ c) & d ~ a & c) + (a>>2 ~ a>>13 ~ a>>22)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      function sha512_feed_128(H, _, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 128\n         local W, K = common_W, sha2_K_lo\n         local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n         for pos = offs + 1, offs + size, 128 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8i8\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-15]\n               local b = W[j-2]\n               W[j] = (a >> 1 ~ a >> 7 ~ a >> 8 ~ a << 56 ~ a << 63) + (b >> 6 ~ b >> 19 ~ b >> 61 ~ b << 3 ~ b << 45) + W[j-7] + W[j-16]\n            end\n            local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n            for j = 1, 80 do\n               local z = (e >> 14 ~ e >> 18 ~ e >> 41 ~ e << 23 ~ e << 46 ~ e << 50) + (g ~ e & (f ~ g)) + h + K[j] + W[j]\n               h = g\n               g = f\n               f = e\n               e = z + d\n               d = c\n               c = b\n               b = a\n               a = z + ((a ~ c) & d ~ a & c) + (a >> 28 ~ a >> 34 ~ a >> 39 ~ a << 25 ~ a << 30 ~ a << 36)\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n            h6 = f + h6\n            h7 = g + h7\n            h8 = h + h8\n         end\n         H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n      end\n\n      function md5_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n         local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            local a, b, c, d = h1, h2, h3, h4\n            local s = 32-7\n            for j = 1, 16 do\n               local F = (d ~ b & (c ~ d)) + a + K[j] + W[j]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-5\n            for j = 17, 32 do\n               local F = (c ~ d & (b ~ c)) + a + K[j] + W[(5*j-4 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-4\n            for j = 33, 48 do\n               local F = (b ~ c ~ d) + a + K[j] + W[(3*j+2 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            s = 32-6\n            for j = 49, 64 do\n               local F = (c ~ (b | ~d)) + a + K[j] + W[(j*7-7 & 15) + 1]\n               a = d\n               d = c\n               c = b\n               b = ((F<<32 | F & (1<<32)-1) >> s) + b\n               s = md5_next_shift[s]\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n         end\n         H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n      end\n\n      function sha1_feed_64(H, str, offs, size)\n         -- offs >= 0, size >= 0, size is multiple of 64\n         local W = common_W\n         local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n         for pos = offs + 1, offs + size, 64 do\n            W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15], W[16] =\n               string_unpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\", str, pos)\n            for j = 17, 80 do\n               local a = W[j-3] ~ W[j-8] ~ W[j-14] ~ W[j-16]\n               W[j] = (a<<32 | a) << 1 >> 32\n            end\n            local a, b, c, d, e = h1, h2, h3, h4, h5\n            for j = 1, 20 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (d ~ b & (c ~ d)) + 0x5A827999 + W[j] + e      -- constant = floor(2^30 * sqrt(2))\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 21, 40 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0x6ED9EBA1 + W[j] + e            -- 2^30 * sqrt(3)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 41, 60 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + ((b ~ c) & d ~ b & c) + 0x8F1BBCDC + W[j] + e  -- 2^30 * sqrt(5)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            for j = 61, 80 do\n               local z = ((a<<32 | a & (1<<32)-1) >> 27) + (b ~ c ~ d) + 0xCA62C1D6 + W[j] + e            -- 2^30 * sqrt(10)\n               e = d\n               d = c\n               c = (b<<32 | b & (1<<32)-1) >> 2\n               b = a\n               a = z\n            end\n            h1 = a + h1\n            h2 = b + h2\n            h3 = c + h3\n            h4 = d + h4\n            h5 = e + h5\n         end\n         H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n      end\n\n      local keccak_format_i8 = build_keccak_format(\"i8\")\n\n      function keccak_feed(lanes, _, str, offs, size, block_size_in_bytes)\n         -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n         local RC = sha3_RC_lo\n         local qwords_qty = block_size_in_bytes \/ 8\n         local keccak_format = keccak_format_i8[qwords_qty]\n         for pos = offs + 1, offs + size, block_size_in_bytes do\n            local qwords_from_message = {string_unpack(keccak_format, str, pos)}\n            for j = 1, qwords_qty do\n               lanes[j] = lanes[j] ~ qwords_from_message[j]\n            end\n            local L01, L02, L03, L04, L05, L06, L07, L08, L09, L10, L11, L12, L13, L14, L15, L16, L17, L18, L19, L20, L21, L22, L23, L24, L25 =\n               lanes[1], lanes[2], lanes[3], lanes[4], lanes[5], lanes[6], lanes[7], lanes[8], lanes[9], lanes[10], lanes[11], lanes[12], lanes[13],\n               lanes[14], lanes[15], lanes[16], lanes[17], lanes[18], lanes[19], lanes[20], lanes[21], lanes[22], lanes[23], lanes[24], lanes[25]\n            for round_idx = 1, 24 do\n               local C1 = L01 ~ L06 ~ L11 ~ L16 ~ L21\n               local C2 = L02 ~ L07 ~ L12 ~ L17 ~ L22\n               local C3 = L03 ~ L08 ~ L13 ~ L18 ~ L23\n               local C4 = L04 ~ L09 ~ L14 ~ L19 ~ L24\n               local C5 = L05 ~ L10 ~ L15 ~ L20 ~ L25\n               local D = C1 ~ C3<<1 ~ C3>>63\n               local T0 = D ~ L02\n               local T1 = D ~ L07\n               local T2 = D ~ L12\n               local T3 = D ~ L17\n               local T4 = D ~ L22\n               L02 = T1<<44 ~ T1>>20\n               L07 = T3<<45 ~ T3>>19\n               L12 = T0<<1 ~ T0>>63\n               L17 = T2<<10 ~ T2>>54\n               L22 = T4<<2 ~ T4>>62\n               D = C2 ~ C4<<1 ~ C4>>63\n               T0 = D ~ L03\n               T1 = D ~ L08\n               T2 = D ~ L13\n               T3 = D ~ L18\n               T4 = D ~ L23\n               L03 = T2<<43 ~ T2>>21\n               L08 = T4<<61 ~ T4>>3\n               L13 = T1<<6 ~ T1>>58\n               L18 = T3<<15 ~ T3>>49\n               L23 = T0<<62 ~ T0>>2\n               D = C3 ~ C5<<1 ~ C5>>63\n               T0 = D ~ L04\n               T1 = D ~ L09\n               T2 = D ~ L14\n               T3 = D ~ L19\n               T4 = D ~ L24\n               L04 = T3<<21 ~ T3>>43\n               L09 = T0<<28 ~ T0>>36\n               L14 = T2<<25 ~ T2>>39\n               L19 = T4<<56 ~ T4>>8\n               L24 = T1<<55 ~ T1>>9\n               D = C4 ~ C1<<1 ~ C1>>63\n               T0 = D ~ L05\n               T1 = D ~ L10\n               T2 = D ~ L15\n               T3 = D ~ L20\n               T4 = D ~ L25\n               L05 = T4<<14 ~ T4>>50\n               L10 = T1<<20 ~ T1>>44\n               L15 = T3<<8 ~ T3>>56\n               L20 = T0<<27 ~ T0>>37\n               L25 = T2<<39 ~ T2>>25\n               D = C5 ~ C2<<1 ~ C2>>63\n               T1 = D ~ L06\n               T2 = D ~ L11\n               T3 = D ~ L16\n               T4 = D ~ L21\n               L06 = T2<<3 ~ T2>>61\n               L11 = T4<<18 ~ T4>>46\n               L16 = T1<<36 ~ T1>>28\n               L21 = T3<<41 ~ T3>>23\n               L01 = D ~ L01\n               L01, L02, L03, L04, L05 = L01 ~ ~L02 & L03, L02 ~ ~L03 & L04, L03 ~ ~L04 & L05, L04 ~ ~L05 & L01, L05 ~ ~L01 & L02\n               L06, L07, L08, L09, L10 = L09 ~ ~L10 & L06, L10 ~ ~L06 & L07, L06 ~ ~L07 & L08, L07 ~ ~L08 & L09, L08 ~ ~L09 & L10\n               L11, L12, L13, L14, L15 = L12 ~ ~L13 & L14, L13 ~ ~L14 & L15, L14 ~ ~L15 & L11, L15 ~ ~L11 & L12, L11 ~ ~L12 & L13\n               L16, L17, L18, L19, L20 = L20 ~ ~L16 & L17, L16 ~ ~L17 & L18, L17 ~ ~L18 & L19, L18 ~ ~L19 & L20, L19 ~ ~L20 & L16\n               L21, L22, L23, L24, L25 = L23 ~ ~L24 & L25, L24 ~ ~L25 & L21, L25 ~ ~L21 & L22, L21 ~ ~L22 & L23, L22 ~ ~L23 & L24\n               L01 = L01 ~ RC[round_idx]\n            end\n            lanes[1]  = L01\n            lanes[2]  = L02\n            lanes[3]  = L03\n            lanes[4]  = L04\n            lanes[5]  = L05\n            lanes[6]  = L06\n            lanes[7]  = L07\n            lanes[8]  = L08\n            lanes[9]  = L09\n            lanes[10] = L10\n            lanes[11] = L11\n            lanes[12] = L12\n            lanes[13] = L13\n            lanes[14] = L14\n            lanes[15] = L15\n            lanes[16] = L16\n            lanes[17] = L17\n            lanes[18] = L18\n            lanes[19] = L19\n            lanes[20] = L20\n            lanes[21] = L21\n            lanes[22] = L22\n            lanes[23] = L23\n            lanes[24] = L24\n            lanes[25] = L25\n         end\n      end\nend\n\nif branch == \"LIB32\" or branch == \"EMUL\" then\n   -- implementation for Lua 5.1\/5.2 (with or without bitwise library available)\n\n   function sha256_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K = common_W, sha2_K_hi\n      local h1, h2, h3, h4, h5, h6, h7, h8 = H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 64 do\n            local a, b = W[j-15], W[j-2]\n            W[j] = XOR(ROR(a, 7), ROL(a, 14), SHR(a, 3)) + XOR(ROL(b, 15), ROL(b, 13), SHR(b, 10)) + W[j-7] + W[j-16]\n         end\n         local a, b, c, d, e, f, g, h = h1, h2, h3, h4, h5, h6, h7, h8\n         for j = 1, 64 do\n            local z = XOR(ROR(e, 6), ROR(e, 11), ROL(e, 7)) + AND(e, f) + AND(-1-e, g) + h + K[j] + W[j]\n            h = g\n            g = f\n            f = e\n            e = z + d\n            d = c\n            c = b\n            b = a\n            a = z + AND(d, c) + AND(a, XOR(d, c)) + XOR(ROR(a, 2), ROR(a, 13), ROL(a, 10))\n         end\n         h1, h2, h3, h4 = (a + h1) % 4294967296, (b + h2) % 4294967296, (c + h3) % 4294967296, (d + h4) % 4294967296\n         h5, h6, h7, h8 = (e + h5) % 4294967296, (f + h6) % 4294967296, (g + h7) % 4294967296, (h + h8) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5], H[6], H[7], H[8] = h1, h2, h3, h4, h5, h6, h7, h8\n   end\n\n   function sha512_feed_128(H_lo, H_hi, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 128\n      -- W1_hi, W1_lo, W2_hi, W2_lo, ...   Wk_hi = W[2*k-1], Wk_lo = W[2*k]\n      local W, K_lo, K_hi = common_W, sha2_K_lo, sha2_K_hi\n      local h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo = H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8]\n      local h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi = H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8]\n      for pos = offs, offs + size - 1, 128 do\n         for j = 1, 16*2 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for jj = 17*2, 80*2, 2 do\n            local a_lo, a_hi, b_lo, b_hi = W[jj-30], W[jj-31], W[jj-4], W[jj-5]\n            local tmp1 = XOR(SHR(a_lo, 1) + SHL(a_hi, 31), SHR(a_lo, 8) + SHL(a_hi, 24), SHR(a_lo, 7) + SHL(a_hi, 25)) % 4294967296 + XOR(SHR(b_lo, 19) + SHL(b_hi, 13), SHL(b_lo, 3) + SHR(b_hi, 29), SHR(b_lo, 6) + SHL(b_hi, 26)) % 4294967296 + W[jj-14] + W[jj-32]\n            local tmp2 = tmp1 % 4294967296\n            W[jj-1] = XOR(SHR(a_hi, 1) + SHL(a_lo, 31), SHR(a_hi, 8) + SHL(a_lo, 24), SHR(a_hi, 7)) + XOR(SHR(b_hi, 19) + SHL(b_lo, 13), SHL(b_hi, 3) + SHR(b_lo, 29), SHR(b_hi, 6)) + W[jj-15] + W[jj-33] + (tmp1 - tmp2) \/ 4294967296\n            W[jj] = tmp2\n         end\n         local a_lo, b_lo, c_lo, d_lo, e_lo, f_lo, g_lo, h_lo = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n         local a_hi, b_hi, c_hi, d_hi, e_hi, f_hi, g_hi, h_hi = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n         for j = 1, 80 do\n            local jj = 2*j\n            local tmp1 = XOR(SHR(e_lo, 14) + SHL(e_hi, 18), SHR(e_lo, 18) + SHL(e_hi, 14), SHL(e_lo, 23) + SHR(e_hi, 9)) % 4294967296 + (AND(e_lo, f_lo) + AND(-1-e_lo, g_lo)) % 4294967296 + h_lo + K_lo[j] + W[jj]\n            local z_lo = tmp1 % 4294967296\n            local z_hi = XOR(SHR(e_hi, 14) + SHL(e_lo, 18), SHR(e_hi, 18) + SHL(e_lo, 14), SHL(e_hi, 23) + SHR(e_lo, 9)) + AND(e_hi, f_hi) + AND(-1-e_hi, g_hi) + h_hi + K_hi[j] + W[jj-1] + (tmp1 - z_lo) \/ 4294967296\n            h_lo = g_lo\n            h_hi = g_hi\n            g_lo = f_lo\n            g_hi = f_hi\n            f_lo = e_lo\n            f_hi = e_hi\n            tmp1 = z_lo + d_lo\n            e_lo = tmp1 % 4294967296\n            e_hi = z_hi + d_hi + (tmp1 - e_lo) \/ 4294967296\n            d_lo = c_lo\n            d_hi = c_hi\n            c_lo = b_lo\n            c_hi = b_hi\n            b_lo = a_lo\n            b_hi = a_hi\n            tmp1 = z_lo + (AND(d_lo, c_lo) + AND(b_lo, XOR(d_lo, c_lo))) % 4294967296 + XOR(SHR(b_lo, 28) + SHL(b_hi, 4), SHL(b_lo, 30) + SHR(b_hi, 2), SHL(b_lo, 25) + SHR(b_hi, 7)) % 4294967296\n            a_lo = tmp1 % 4294967296\n            a_hi = z_hi + (AND(d_hi, c_hi) + AND(b_hi, XOR(d_hi, c_hi))) + XOR(SHR(b_hi, 28) + SHL(b_lo, 4), SHL(b_hi, 30) + SHR(b_lo, 2), SHL(b_hi, 25) + SHR(b_lo, 7)) + (tmp1 - a_lo) \/ 4294967296\n         end\n         a_lo = h1_lo + a_lo\n         h1_lo = a_lo % 4294967296\n         h1_hi = (h1_hi + a_hi + (a_lo - h1_lo) \/ 4294967296) % 4294967296\n         a_lo = h2_lo + b_lo\n         h2_lo = a_lo % 4294967296\n         h2_hi = (h2_hi + b_hi + (a_lo - h2_lo) \/ 4294967296) % 4294967296\n         a_lo = h3_lo + c_lo\n         h3_lo = a_lo % 4294967296\n         h3_hi = (h3_hi + c_hi + (a_lo - h3_lo) \/ 4294967296) % 4294967296\n         a_lo = h4_lo + d_lo\n         h4_lo = a_lo % 4294967296\n         h4_hi = (h4_hi + d_hi + (a_lo - h4_lo) \/ 4294967296) % 4294967296\n         a_lo = h5_lo + e_lo\n         h5_lo = a_lo % 4294967296\n         h5_hi = (h5_hi + e_hi + (a_lo - h5_lo) \/ 4294967296) % 4294967296\n         a_lo = h6_lo + f_lo\n         h6_lo = a_lo % 4294967296\n         h6_hi = (h6_hi + f_hi + (a_lo - h6_lo) \/ 4294967296) % 4294967296\n         a_lo = h7_lo + g_lo\n         h7_lo = a_lo % 4294967296\n         h7_hi = (h7_hi + g_hi + (a_lo - h7_lo) \/ 4294967296) % 4294967296\n         a_lo = h8_lo + h_lo\n         h8_lo = a_lo % 4294967296\n         h8_hi = (h8_hi + h_hi + (a_lo - h8_lo) \/ 4294967296) % 4294967296\n      end\n      H_lo[1], H_lo[2], H_lo[3], H_lo[4], H_lo[5], H_lo[6], H_lo[7], H_lo[8] = h1_lo, h2_lo, h3_lo, h4_lo, h5_lo, h6_lo, h7_lo, h8_lo\n      H_hi[1], H_hi[2], H_hi[3], H_hi[4], H_hi[5], H_hi[6], H_hi[7], H_hi[8] = h1_hi, h2_hi, h3_hi, h4_hi, h5_hi, h6_hi, h7_hi, h8_hi\n   end\n\n   function md5_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W, K, md5_next_shift = common_W, md5_K, md5_next_shift\n      local h1, h2, h3, h4 = H[1], H[2], H[3], H[4]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((d * 256 + c) * 256 + b) * 256 + a\n         end\n         local a, b, c, d = h1, h2, h3, h4\n         local s = 32-7\n         for j = 1, 16 do\n            local F = ROR(AND(b, c) + AND(-1-b, d) + a + K[j] + W[j], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-5\n         for j = 17, 32 do\n            local F = ROR(AND(d, b) + AND(-1-d, c) + a + K[j] + W[(5*j-4) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-4\n         for j = 33, 48 do\n            local F = ROR(XOR(XOR(b, c), d) + a + K[j] + W[(3*j+2) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         s = 32-6\n         for j = 49, 64 do\n            local F = ROR(XOR(c, OR(b, -1-d)) + a + K[j] + W[(j*7-7) % 16 + 1], s) + b\n            s = md5_next_shift[s]\n            a = d\n            d = c\n            c = b\n            b = F\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n      end\n      H[1], H[2], H[3], H[4] = h1, h2, h3, h4\n   end\n\n   function sha1_feed_64(H, str, offs, size)\n      -- offs >= 0, size >= 0, size is multiple of 64\n      local W = common_W\n      local h1, h2, h3, h4, h5 = H[1], H[2], H[3], H[4], H[5]\n      for pos = offs, offs + size - 1, 64 do\n         for j = 1, 16 do\n            pos = pos + 4\n            local a, b, c, d = byte(str, pos - 3, pos)\n            W[j] = ((a * 256 + b) * 256 + c) * 256 + d\n         end\n         for j = 17, 80 do\n            W[j] = ROL(XOR(W[j-3], W[j-8], W[j-14], W[j-16]), 1)\n         end\n         local a, b, c, d, e = h1, h2, h3, h4, h5\n         for j = 1, 20 do\n            local z = ROL(a, 5) + AND(b, c) + AND(-1-b, d) + 0x5A827999 + W[j] + e        -- constant = floor(2^30 * sqrt(2))\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 21, 40 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0x6ED9EBA1 + W[j] + e                    -- 2^30 * sqrt(3)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 41, 60 do\n            local z = ROL(a, 5) + AND(d, c) + AND(b, XOR(d, c)) + 0x8F1BBCDC + W[j] + e   -- 2^30 * sqrt(5)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         for j = 61, 80 do\n            local z = ROL(a, 5) + XOR(b, c, d) + 0xCA62C1D6 + W[j] + e                    -- 2^30 * sqrt(10)\n            e = d\n            d = c\n            c = ROR(b, 2)\n            b = a\n            a = z\n         end\n         h1 = (a + h1) % 4294967296\n         h2 = (b + h2) % 4294967296\n         h3 = (c + h3) % 4294967296\n         h4 = (d + h4) % 4294967296\n         h5 = (e + h5) % 4294967296\n      end\n      H[1], H[2], H[3], H[4], H[5] = h1, h2, h3, h4, h5\n   end\n\n   function keccak_feed(lanes_lo, lanes_hi, str, offs, size, block_size_in_bytes)\n      -- This is an example of a Lua function having 79 local variables :-)\n      -- offs >= 0, size >= 0, size is multiple of block_size_in_bytes, block_size_in_bytes is positive multiple of 8\n      local RC_lo, RC_hi = sha3_RC_lo, sha3_RC_hi\n      local qwords_qty = block_size_in_bytes \/ 8\n      for pos = offs, offs + size - 1, block_size_in_bytes do\n         for j = 1, qwords_qty do\n            local a, b, c, d = byte(str, pos + 1, pos + 4)\n            lanes_lo[j] = XOR(lanes_lo[j], ((d * 256 + c) * 256 + b) * 256 + a)\n            pos = pos + 8\n            a, b, c, d = byte(str, pos - 3, pos)\n            lanes_hi[j] = XOR(lanes_hi[j], ((d * 256 + c) * 256 + b) * 256 + a)\n         end\n         local L01_lo, L01_hi, L02_lo, L02_hi, L03_lo, L03_hi, L04_lo, L04_hi, L05_lo, L05_hi, L06_lo, L06_hi, L07_lo, L07_hi, L08_lo, L08_hi,\n            L09_lo, L09_hi, L10_lo, L10_hi, L11_lo, L11_hi, L12_lo, L12_hi, L13_lo, L13_hi, L14_lo, L14_hi, L15_lo, L15_hi, L16_lo, L16_hi,\n            L17_lo, L17_hi, L18_lo, L18_hi, L19_lo, L19_hi, L20_lo, L20_hi, L21_lo, L21_hi, L22_lo, L22_hi, L23_lo, L23_hi, L24_lo, L24_hi, L25_lo, L25_hi =\n            lanes_lo[1], lanes_hi[1], lanes_lo[2], lanes_hi[2], lanes_lo[3], lanes_hi[3], lanes_lo[4], lanes_hi[4], lanes_lo[5], lanes_hi[5],\n            lanes_lo[6], lanes_hi[6], lanes_lo[7], lanes_hi[7], lanes_lo[8], lanes_hi[8], lanes_lo[9], lanes_hi[9], lanes_lo[10], lanes_hi[10],\n            lanes_lo[11], lanes_hi[11], lanes_lo[12], lanes_hi[12], lanes_lo[13], lanes_hi[13], lanes_lo[14], lanes_hi[14], lanes_lo[15], lanes_hi[15],\n            lanes_lo[16], lanes_hi[16], lanes_lo[17], lanes_hi[17], lanes_lo[18], lanes_hi[18], lanes_lo[19], lanes_hi[19], lanes_lo[20], lanes_hi[20],\n            lanes_lo[21], lanes_hi[21], lanes_lo[22], lanes_hi[22], lanes_lo[23], lanes_hi[23], lanes_lo[24], lanes_hi[24], lanes_lo[25], lanes_hi[25]\n         for round_idx = 1, 24 do\n            local C1_lo = XOR(L01_lo, L06_lo, L11_lo, L16_lo, L21_lo)\n            local C1_hi = XOR(L01_hi, L06_hi, L11_hi, L16_hi, L21_hi)\n            local C2_lo = XOR(L02_lo, L07_lo, L12_lo, L17_lo, L22_lo)\n            local C2_hi = XOR(L02_hi, L07_hi, L12_hi, L17_hi, L22_hi)\n            local C3_lo = XOR(L03_lo, L08_lo, L13_lo, L18_lo, L23_lo)\n            local C3_hi = XOR(L03_hi, L08_hi, L13_hi, L18_hi, L23_hi)\n            local C4_lo = XOR(L04_lo, L09_lo, L14_lo, L19_lo, L24_lo)\n            local C4_hi = XOR(L04_hi, L09_hi, L14_hi, L19_hi, L24_hi)\n            local C5_lo = XOR(L05_lo, L10_lo, L15_lo, L20_lo, L25_lo)\n            local C5_hi = XOR(L05_hi, L10_hi, L15_hi, L20_hi, L25_hi)\n            local D_lo = XOR(C1_lo, C3_lo * 2 + (C3_hi % 2^32 - C3_hi % 2^31) \/ 2^31)\n            local D_hi = XOR(C1_hi, C3_hi * 2 + (C3_lo % 2^32 - C3_lo % 2^31) \/ 2^31)\n            local T0_lo = XOR(D_lo, L02_lo)\n            local T0_hi = XOR(D_hi, L02_hi)\n            local T1_lo = XOR(D_lo, L07_lo)\n            local T1_hi = XOR(D_hi, L07_hi)\n            local T2_lo = XOR(D_lo, L12_lo)\n            local T2_hi = XOR(D_hi, L12_hi)\n            local T3_lo = XOR(D_lo, L17_lo)\n            local T3_hi = XOR(D_hi, L17_hi)\n            local T4_lo = XOR(D_lo, L22_lo)\n            local T4_hi = XOR(D_hi, L22_hi)\n            L02_lo = (T1_lo % 2^32 - T1_lo % 2^20) \/ 2^20 + T1_hi * 2^12\n            L02_hi = (T1_hi % 2^32 - T1_hi % 2^20) \/ 2^20 + T1_lo * 2^12\n            L07_lo = (T3_lo % 2^32 - T3_lo % 2^19) \/ 2^19 + T3_hi * 2^13\n            L07_hi = (T3_hi % 2^32 - T3_hi % 2^19) \/ 2^19 + T3_lo * 2^13\n            L12_lo = T0_lo * 2 + (T0_hi % 2^32 - T0_hi % 2^31) \/ 2^31\n            L12_hi = T0_hi * 2 + (T0_lo % 2^32 - T0_lo % 2^31) \/ 2^31\n            L17_lo = T2_lo * 2^10 + (T2_hi % 2^32 - T2_hi % 2^22) \/ 2^22\n            L17_hi = T2_hi * 2^10 + (T2_lo % 2^32 - T2_lo % 2^22) \/ 2^22\n            L22_lo = T4_lo * 2^2 + (T4_hi % 2^32 - T4_hi % 2^30) \/ 2^30\n            L22_hi = T4_hi * 2^2 + (T4_lo % 2^32 - T4_lo % 2^30) \/ 2^30\n            D_lo = XOR(C2_lo, C4_lo * 2 + (C4_hi % 2^32 - C4_hi % 2^31) \/ 2^31)\n            D_hi = XOR(C2_hi, C4_hi * 2 + (C4_lo % 2^32 - C4_lo % 2^31) \/ 2^31)\n            T0_lo = XOR(D_lo, L03_lo)\n            T0_hi = XOR(D_hi, L03_hi)\n            T1_lo = XOR(D_lo, L08_lo)\n            T1_hi = XOR(D_hi, L08_hi)\n            T2_lo = XOR(D_lo, L13_lo)\n            T2_hi = XOR(D_hi, L13_hi)\n            T3_lo = XOR(D_lo, L18_lo)\n            T3_hi = XOR(D_hi, L18_hi)\n            T4_lo = XOR(D_lo, L23_lo)\n            T4_hi = XOR(D_hi, L23_hi)\n            L03_lo = (T2_lo % 2^32 - T2_lo % 2^21) \/ 2^21 + T2_hi * 2^11\n            L03_hi = (T2_hi % 2^32 - T2_hi % 2^21) \/ 2^21 + T2_lo * 2^11\n            L08_lo = (T4_lo % 2^32 - T4_lo % 2^3) \/ 2^3 + T4_hi * 2^29 % 2^32\n            L08_hi = (T4_hi % 2^32 - T4_hi % 2^3) \/ 2^3 + T4_lo * 2^29 % 2^32\n            L13_lo = T1_lo * 2^6 + (T1_hi % 2^32 - T1_hi % 2^26) \/ 2^26\n            L13_hi = T1_hi * 2^6 + (T1_lo % 2^32 - T1_lo % 2^26) \/ 2^26\n            L18_lo = T3_lo * 2^15 + (T3_hi % 2^32 - T3_hi % 2^17) \/ 2^17\n            L18_hi = T3_hi * 2^15 + (T3_lo % 2^32 - T3_lo % 2^17) \/ 2^17\n            L23_lo = (T0_lo % 2^32 - T0_lo % 2^2) \/ 2^2 + T0_hi * 2^30 % 2^32\n            L23_hi = (T0_hi % 2^32 - T0_hi % 2^2) \/ 2^2 + T0_lo * 2^30 % 2^32\n            D_lo = XOR(C3_lo, C5_lo * 2 + (C5_hi % 2^32 - C5_hi % 2^31) \/ 2^31)\n            D_hi = XOR(C3_hi, C5_hi * 2 + (C5_lo % 2^32 - C5_lo % 2^31) \/ 2^31)\n            T0_lo = XOR(D_lo, L04_lo)\n            T0_hi = XOR(D_hi, L04_hi)\n            T1_lo = XOR(D_lo, L09_lo)\n            T1_hi = XOR(D_hi, L09_hi)\n            T2_lo = XOR(D_lo, L14_lo)\n            T2_hi = XOR(D_hi, L14_hi)\n            T3_lo = XOR(D_lo, L19_lo)\n            T3_hi = XOR(D_hi, L19_hi)\n            T4_lo = XOR(D_lo, L24_lo)\n            T4_hi = XOR(D_hi, L24_hi)\n            L04_lo = T3_lo * 2^21 % 2^32 + (T3_hi % 2^32 - T3_hi % 2^11) \/ 2^11\n            L04_hi = T3_hi * 2^21 % 2^32 + (T3_lo % 2^32 - T3_lo % 2^11) \/ 2^11\n            L09_lo = T0_lo * 2^28 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^4) \/ 2^4\n            L09_hi = T0_hi * 2^28 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^4) \/ 2^4\n            L14_lo = T2_lo * 2^25 % 2^32 + (T2_hi % 2^32 - T2_hi % 2^7) \/ 2^7\n            L14_hi = T2_hi * 2^25 % 2^32 + (T2_lo % 2^32 - T2_lo % 2^7) \/ 2^7\n            L19_lo = (T4_lo % 2^32 - T4_lo % 2^8) \/ 2^8 + T4_hi * 2^24 % 2^32\n            L19_hi = (T4_hi % 2^32 - T4_hi % 2^8) \/ 2^8 + T4_lo * 2^24 % 2^32\n            L24_lo = (T1_lo % 2^32 - T1_lo % 2^9) \/ 2^9 + T1_hi * 2^23 % 2^32\n            L24_hi = (T1_hi % 2^32 - T1_hi % 2^9) \/ 2^9 + T1_lo * 2^23 % 2^32\n            D_lo = XOR(C4_lo, C1_lo * 2 + (C1_hi % 2^32 - C1_hi % 2^31) \/ 2^31)\n            D_hi = XOR(C4_hi, C1_hi * 2 + (C1_lo % 2^32 - C1_lo % 2^31) \/ 2^31)\n            T0_lo = XOR(D_lo, L05_lo)\n            T0_hi = XOR(D_hi, L05_hi)\n            T1_lo = XOR(D_lo, L10_lo)\n            T1_hi = XOR(D_hi, L10_hi)\n            T2_lo = XOR(D_lo, L15_lo)\n            T2_hi = XOR(D_hi, L15_hi)\n            T3_lo = XOR(D_lo, L20_lo)\n            T3_hi = XOR(D_hi, L20_hi)\n            T4_lo = XOR(D_lo, L25_lo)\n            T4_hi = XOR(D_hi, L25_hi)\n            L05_lo = T4_lo * 2^14 + (T4_hi % 2^32 - T4_hi % 2^18) \/ 2^18\n            L05_hi = T4_hi * 2^14 + (T4_lo % 2^32 - T4_lo % 2^18) \/ 2^18\n            L10_lo = T1_lo * 2^20 % 2^32 + (T1_hi % 2^32 - T1_hi % 2^12) \/ 2^12\n            L10_hi = T1_hi * 2^20 % 2^32 + (T1_lo % 2^32 - T1_lo % 2^12) \/ 2^12\n            L15_lo = T3_lo * 2^8 + (T3_hi % 2^32 - T3_hi % 2^24) \/ 2^24\n            L15_hi = T3_hi * 2^8 + (T3_lo % 2^32 - T3_lo % 2^24) \/ 2^24\n            L20_lo = T0_lo * 2^27 % 2^32 + (T0_hi % 2^32 - T0_hi % 2^5) \/ 2^5\n            L20_hi = T0_hi * 2^27 % 2^32 + (T0_lo % 2^32 - T0_lo % 2^5) \/ 2^5\n            L25_lo = (T2_lo % 2^32 - T2_lo % 2^25) \/ 2^25 + T2_hi * 2^7\n            L25_hi = (T2_hi % 2^32 - T2_hi % 2^25) \/ 2^25 + T2_lo * 2^7\n            D_lo = XOR(C5_lo, C2_lo * 2 + (C2_hi % 2^32 - C2_hi % 2^31) \/ 2^31)\n            D_hi = XOR(C5_hi, C2_hi * 2 + (C2_lo % 2^32 - C2_lo % 2^31) \/ 2^31)\n            T1_lo = XOR(D_lo, L06_lo)\n            T1_hi = XOR(D_hi, L06_hi)\n            T2_lo = XOR(D_lo, L11_lo)\n            T2_hi = XOR(D_hi, L11_hi)\n            T3_lo = XOR(D_lo, L16_lo)\n            T3_hi = XOR(D_hi, L16_hi)\n            T4_lo = XOR(D_lo, L21_lo)\n            T4_hi = XOR(D_hi, L21_hi)\n            L06_lo = T2_lo * 2^3 + (T2_hi % 2^32 - T2_hi % 2^29) \/ 2^29\n            L06_hi = T2_hi * 2^3 + (T2_lo % 2^32 - T2_lo % 2^29) \/ 2^29\n            L11_lo = T4_lo * 2^18 + (T4_hi % 2^32 - T4_hi % 2^14) \/ 2^14\n            L11_hi = T4_hi * 2^18 + (T4_lo % 2^32 - T4_lo % 2^14) \/ 2^14\n            L16_lo = (T1_lo % 2^32 - T1_lo % 2^28) \/ 2^28 + T1_hi * 2^4\n            L16_hi = (T1_hi % 2^32 - T1_hi % 2^28) \/ 2^28 + T1_lo * 2^4\n            L21_lo = (T3_lo % 2^32 - T3_lo % 2^23) \/ 2^23 + T3_hi * 2^9\n            L21_hi = (T3_hi % 2^32 - T3_hi % 2^23) \/ 2^23 + T3_lo * 2^9\n            L01_lo = XOR(D_lo, L01_lo)\n            L01_hi = XOR(D_hi, L01_hi)\n            L01_lo, L02_lo, L03_lo, L04_lo, L05_lo = XOR(L01_lo, AND(-1-L02_lo, L03_lo)), XOR(L02_lo, AND(-1-L03_lo, L04_lo)), XOR(L03_lo, AND(-1-L04_lo, L05_lo)), XOR(L04_lo, AND(-1-L05_lo, L01_lo)), XOR(L05_lo, AND(-1-L01_lo, L02_lo))\n            L01_hi, L02_hi, L03_hi, L04_hi, L05_hi = XOR(L01_hi, AND(-1-L02_hi, L03_hi)), XOR(L02_hi, AND(-1-L03_hi, L04_hi)), XOR(L03_hi, AND(-1-L04_hi, L05_hi)), XOR(L04_hi, AND(-1-L05_hi, L01_hi)), XOR(L05_hi, AND(-1-L01_hi, L02_hi))\n            L06_lo, L07_lo, L08_lo, L09_lo, L10_lo = XOR(L09_lo, AND(-1-L10_lo, L06_lo)), XOR(L10_lo, AND(-1-L06_lo, L07_lo)), XOR(L06_lo, AND(-1-L07_lo, L08_lo)), XOR(L07_lo, AND(-1-L08_lo, L09_lo)), XOR(L08_lo, AND(-1-L09_lo, L10_lo))\n            L06_hi, L07_hi, L08_hi, L09_hi, L10_hi = XOR(L09_hi, AND(-1-L10_hi, L06_hi)), XOR(L10_hi, AND(-1-L06_hi, L07_hi)), XOR(L06_hi, AND(-1-L07_hi, L08_hi)), XOR(L07_hi, AND(-1-L08_hi, L09_hi)), XOR(L08_hi, AND(-1-L09_hi, L10_hi))\n            L11_lo, L12_lo, L13_lo, L14_lo, L15_lo = XOR(L12_lo, AND(-1-L13_lo, L14_lo)), XOR(L13_lo, AND(-1-L14_lo, L15_lo)), XOR(L14_lo, AND(-1-L15_lo, L11_lo)), XOR(L15_lo, AND(-1-L11_lo, L12_lo)), XOR(L11_lo, AND(-1-L12_lo, L13_lo))\n            L11_hi, L12_hi, L13_hi, L14_hi, L15_hi = XOR(L12_hi, AND(-1-L13_hi, L14_hi)), XOR(L13_hi, AND(-1-L14_hi, L15_hi)), XOR(L14_hi, AND(-1-L15_hi, L11_hi)), XOR(L15_hi, AND(-1-L11_hi, L12_hi)), XOR(L11_hi, AND(-1-L12_hi, L13_hi))\n            L16_lo, L17_lo, L18_lo, L19_lo, L20_lo = XOR(L20_lo, AND(-1-L16_lo, L17_lo)), XOR(L16_lo, AND(-1-L17_lo, L18_lo)), XOR(L17_lo, AND(-1-L18_lo, L19_lo)), XOR(L18_lo, AND(-1-L19_lo, L20_lo)), XOR(L19_lo, AND(-1-L20_lo, L16_lo))\n            L16_hi, L17_hi, L18_hi, L19_hi, L20_hi = XOR(L20_hi, AND(-1-L16_hi, L17_hi)), XOR(L16_hi, AND(-1-L17_hi, L18_hi)), XOR(L17_hi, AND(-1-L18_hi, L19_hi)), XOR(L18_hi, AND(-1-L19_hi, L20_hi)), XOR(L19_hi, AND(-1-L20_hi, L16_hi))\n            L21_lo, L22_lo, L23_lo, L24_lo, L25_lo = XOR(L23_lo, AND(-1-L24_lo, L25_lo)), XOR(L24_lo, AND(-1-L25_lo, L21_lo)), XOR(L25_lo, AND(-1-L21_lo, L22_lo)), XOR(L21_lo, AND(-1-L22_lo, L23_lo)), XOR(L22_lo, AND(-1-L23_lo, L24_lo))\n            L21_hi, L22_hi, L23_hi, L24_hi, L25_hi = XOR(L23_hi, AND(-1-L24_hi, L25_hi)), XOR(L24_hi, AND(-1-L25_hi, L21_hi)), XOR(L25_hi, AND(-1-L21_hi, L22_hi)), XOR(L21_hi, AND(-1-L22_hi, L23_hi)), XOR(L22_hi, AND(-1-L23_hi, L24_hi))\n            L01_lo = XOR(L01_lo, RC_lo[round_idx])\n            L01_hi = L01_hi + RC_hi[round_idx]      -- RC_hi[] is either 0 or 0x80000000, so we could use fast addition instead of slow XOR\n         end\n         lanes_lo[1]  = L01_lo\n         lanes_hi[1]  = L01_hi\n         lanes_lo[2]  = L02_lo\n         lanes_hi[2]  = L02_hi\n         lanes_lo[3]  = L03_lo\n         lanes_hi[3]  = L03_hi\n         lanes_lo[4]  = L04_lo\n         lanes_hi[4]  = L04_hi\n         lanes_lo[5]  = L05_lo\n         lanes_hi[5]  = L05_hi\n         lanes_lo[6]  = L06_lo\n         lanes_hi[6]  = L06_hi\n         lanes_lo[7]  = L07_lo\n         lanes_hi[7]  = L07_hi\n         lanes_lo[8]  = L08_lo\n         lanes_hi[8]  = L08_hi\n         lanes_lo[9]  = L09_lo\n         lanes_hi[9]  = L09_hi\n         lanes_lo[10] = L10_lo\n         lanes_hi[10] = L10_hi\n         lanes_lo[11] = L11_lo\n         lanes_hi[11] = L11_hi\n         lanes_lo[12] = L12_lo\n         lanes_hi[12] = L12_hi\n         lanes_lo[13] = L13_lo\n         lanes_hi[13] = L13_hi\n         lanes_lo[14] = L14_lo\n         lanes_hi[14] = L14_hi\n         lanes_lo[15] = L15_lo\n         lanes_hi[15] = L15_hi\n         lanes_lo[16] = L16_lo\n         lanes_hi[16] = L16_hi\n         lanes_lo[17] = L17_lo\n         lanes_hi[17] = L17_hi\n         lanes_lo[18] = L18_lo\n         lanes_hi[18] = L18_hi\n         lanes_lo[19] = L19_lo\n         lanes_hi[19] = L19_hi\n         lanes_lo[20] = L20_lo\n         lanes_hi[20] = L20_hi\n         lanes_lo[21] = L21_lo\n         lanes_hi[21] = L21_hi\n         lanes_lo[22] = L22_lo\n         lanes_hi[22] = L22_hi\n         lanes_lo[23] = L23_lo\n         lanes_hi[23] = L23_hi\n         lanes_lo[24] = L24_lo\n         lanes_hi[24] = L24_hi\n         lanes_lo[25] = L25_lo\n         lanes_hi[25] = L25_hi\n      end\n   end\nend\n\n--------------------------------------------------------------------------------\n-- MAGIC NUMBERS CALCULATOR\n--------------------------------------------------------------------------------\n-- Q:\n--    Is 53-bit \"double\" math enough to calculate square roots and cube roots of primes with 64 correct bits after decimal point?\n-- A:\n--    Yes, 53-bit \"double\" arithmetic is enough.\n--    We could obtain first 40 bits by direct calculation of p^(1\/3) and next 40 bits by one step of Newton's method.\n\ndo\n   local function mul(src1, src2, factor, result_length)\n      -- src1, src2 - long integers (arrays of digits in base 2^24)\n      -- factor - small integer\n      -- returns long integer result (src1 * src2 * factor) and its floating point approximation\n      local result, carry, value, weight = {}, 0.0, 0.0, 1.0\n      for j = 1, result_length do\n         for k = math_max(1, j + 1 - #src2), math_min(j, #src1) do\n            carry = carry + factor * src1[k] * src2[j + 1 - k]  -- \"int32\" is not enough for multiplication result, that's why \"factor\" must be of type \"double\"\n         end\n         local digit = carry % 2^24\n         result[j] = floor(digit)\n         carry = (carry - digit) \/ 2^24\n         value = value + digit * weight\n         weight = weight * 2^24\n      end\n      return result, value\n   end\n\n   local idx, step, p, one, sqrt_hi, sqrt_lo = 0, {4, 1, 2, -2, 2}, 4, {1}, sha2_H_hi, sha2_H_lo\n   repeat\n      p = p + step[p % 6]\n      local d = 1\n      repeat\n         d = d + step[d % 6]\n         if d*d > p then -- next prime number is found\n            local root = p^(1\/3)\n            local R = root * 2^40\n            R = mul({R - R % 1}, one, 1.0, 2)\n            local _, delta = mul(R, mul(R, R, 1.0, 4), -1.0, 4)\n            local hi = R[2] % 65536 * 65536 + floor(R[1] \/ 256)\n            local lo = R[1] % 256 * 16777216 + floor(delta * (2^-56 \/ 3) * root \/ p)\n            if idx < 16 then\n               root = p^(1\/2)\n               R = root * 2^40\n               R = mul({R - R % 1}, one, 1.0, 2)\n               _, delta = mul(R, R, -1.0, 2)\n               local hi = R[2] % 65536 * 65536 + floor(R[1] \/ 256)\n               local lo = R[1] % 256 * 16777216 + floor(delta * 2^-17 \/ root)\n               local idx = idx % 8 + 1\n               sha2_H_ext256[224][idx] = lo\n               sqrt_hi[idx], sqrt_lo[idx] = hi, lo + hi * hi_factor\n               if idx > 7 then\n                  sqrt_hi, sqrt_lo = sha2_H_ext512_hi[384], sha2_H_ext512_lo[384]\n               end\n            end\n            idx = idx + 1\n            sha2_K_hi[idx], sha2_K_lo[idx] = hi, lo % K_lo_modulo + hi * hi_factor\n            break\n         end\n      until p % d == 0\n   until idx > 79\nend\n\n-- Calculating IVs for SHA512\/224 and SHA512\/256\nfor width = 224, 256, 32 do\n   local H_lo, H_hi = {}\n   if XOR64A5 then\n      for j = 1, 8 do\n         H_lo[j] = XOR64A5(sha2_H_lo[j])\n      end\n   else\n      H_hi = {}\n      for j = 1, 8 do\n         H_lo[j] = XOR32A5(sha2_H_lo[j])\n         H_hi[j] = XOR32A5(sha2_H_hi[j])\n      end\n   end\n   sha512_feed_128(H_lo, H_hi, \"SHA-512\/\"..tostring(width)..\"\\128\"..string_rep(\"\\0\", 115)..\"\\88\", 0, 128)\n   sha2_H_ext512_lo[width] = H_lo\n   sha2_H_ext512_hi[width] = H_hi\nend\n\n-- Constants for MD5\ndo\n   local sin, abs, modf = math.sin, math.abs, math.modf\n   for idx = 1, 64 do\n      -- we can't use formula floor(abs(sin(idx))*2^32) because its result may be beyond integer range on Lua built with 32-bit integers\n      local hi, lo = modf(abs(sin(idx)) * 2^16)\n      md5_K[idx] = hi * 65536 + floor(lo * 2^16)\n   end\nend\n\n-- Constants for SHA3\ndo\n   local sh_reg = 29\n   local function next_bit()\n      local r = sh_reg % 2\n      sh_reg = XOR_BYTE((sh_reg - r) \/ 2, 142 * r)\n      return r\n   end\n   for idx = 1, 24 do\n      local lo, m = 0\n      for _ = 1, 6 do\n         m = m and m * m * 2 or 1\n         lo = lo + next_bit() * m\n      end\n      local hi = next_bit() * m\n      sha3_RC_hi[idx], sha3_RC_lo[idx] = hi, lo + hi * hi_factor_keccak\n   end\nend\n\n--------------------------------------------------------------------------------\n-- MAIN FUNCTIONS\n--------------------------------------------------------------------------------\n\nlocal function sha256ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(sha2_H_ext256[width])}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha256_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha256_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- Anyway, it looks very unrealistic that someone would spend more than a year of calculations to process 2^53 bytes of data by using this Lua script :-)\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 \/ 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha256_feed_64(H, final_blocks, 0, #final_blocks)\n            local max_reg = width \/ 32\n            for j = 1, max_reg do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H, \"\", 1, max_reg)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA256 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA256 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\nlocal function sha512ext(width, message)\n\n   -- Create an instance (private objects for current calculation)\n   local length, tail, H_lo, H_hi = 0.0, \"\", {unpack(sha2_H_ext512_lo[width])}, not HEX64 and {unpack(sha2_H_ext512_hi[width])}\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 128 then\n               offs = 128 - #tail\n               sha512_feed_128(H_lo, H_hi, tail..sub(message_part, 1, offs), 0, 128)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 128\n            sha512_feed_128(H_lo, H_hi, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-17-length) % 128 + 9)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-17 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 \/ 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move floating point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha512_feed_128(H_lo, H_hi, final_blocks, 0, #final_blocks)\n            local max_reg = ceil(width \/ 64)\n            if HEX64 then\n               for j = 1, max_reg do\n                  H_lo[j] = HEX64(H_lo[j])\n               end\n            else\n               for j = 1, max_reg do\n                  H_lo[j] = HEX(H_hi[j])..HEX(H_lo[j])\n               end\n               H_hi = nil\n            end\n            H_lo = sub(table_concat(H_lo, \"\", 1, max_reg), 1, width \/ 4)\n         end\n         return H_lo\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA512 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA512 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\nlocal function md5(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H, 1, 4)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               md5_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            md5_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64)}\n            tail = nil\n            length = length * 8  -- convert \"byte-counter\" to \"bit-counter\"\n            for j = 4, 11 do\n               local low_byte = length % 256\n               final_blocks[j] = char(low_byte)\n               length = (length - low_byte) \/ 256\n            end\n            final_blocks = table_concat(final_blocks)\n            md5_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 4 do\n               H[j] = HEX(H[j])\n            end\n            H = gsub(table_concat(H), \"(..)(..)(..)(..)\", \"%4%3%2%1\")\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the MD5 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get MD5 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\nlocal function sha1(message)\n\n   -- Create an instance (private objects for current calculation)\n   local H, length, tail = {unpack(md5_sha1_H)}, 0.0, \"\"\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            length = length + #message_part\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= 64 then\n               offs = 64 - #tail\n               sha1_feed_64(H, tail..sub(message_part, 1, offs), 0, 64)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % 64\n            sha1_feed_64(H, message_part, offs, size - size_tail)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            local final_blocks = {tail, \"\\128\", string_rep(\"\\0\", (-9 - length) % 64 + 1)}\n            tail = nil\n            -- Assuming user data length is shorter than (2^53)-9 bytes\n            -- 2^53 bytes = 2^56 bits, so \"bit-counter\" fits in 7 bytes\n            length = length * (8 \/ 256^7)  -- convert \"byte-counter\" to \"bit-counter\" and move decimal point to the left\n            for j = 4, 10 do\n               length = length % 1 * 256\n               final_blocks[j] = char(floor(length))\n            end\n            final_blocks = table_concat(final_blocks)\n            sha1_feed_64(H, final_blocks, 0, #final_blocks)\n            for j = 1, 5 do\n               H[j] = HEX(H[j])\n            end\n            H = table_concat(H)\n         end\n         return H\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA-1 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA-1 digest by invoking this function without an argument\n      return partial\n   end\n\nend\n\nlocal function keccak(block_size_in_bytes, digest_size_in_bytes, is_SHAKE, message)\n   -- \"block_size_in_bytes\" is multiple of 8\n   if type(digest_size_in_bytes) ~= \"number\" then\n      -- arguments in SHAKE are swapped:\n      --    NIST FIPS 202 defines SHAKE(message,num_bits)\n      --    this module   defines SHAKE(num_bytes,message)\n      -- it's easy to forget about this swap, hence the check\n      error(\"Argument 'digest_size_in_bytes' must be a number\", 2)\n   end\n\n   -- Create an instance (private objects for current calculation)\n   local tail, lanes_lo, lanes_hi = \"\", create_array_of_lanes(), hi_factor_keccak == 0 and create_array_of_lanes()\n   local result\n\n--~     pad the input N using the pad function, yielding a padded bit string P with a length divisible by r (such that n = len(P)\/r is integer),\n--~     break P into n consecutive r-bit pieces P0, ..., Pn-1 (last is zero-padded)\n--~     initialize the state S to a string of b 0 bits.\n--~     absorb the input into the state: For each block Pi,\n--~         extend Pi at the end by a string of c 0 bits, yielding one of length b,\n--~         XOR that with S and\n--~         apply the block permutation f to the result, yielding a new state S\n--~     initialize Z to be the empty string\n--~     while the length of Z is less than d:\n--~         append the first r bits of S to Z\n--~         if Z is still less than d bits long, apply f to S, yielding a new state S.\n--~     truncate Z to d bits\n\n   local function partial(message_part)\n      if message_part then\n         if tail then\n            local offs = 0\n            if tail ~= \"\" and #tail + #message_part >= block_size_in_bytes then\n               offs = block_size_in_bytes - #tail\n               keccak_feed(lanes_lo, lanes_hi, tail..sub(message_part, 1, offs), 0, block_size_in_bytes, block_size_in_bytes)\n               tail = \"\"\n            end\n            local size = #message_part - offs\n            local size_tail = size % block_size_in_bytes\n            keccak_feed(lanes_lo, lanes_hi, message_part, offs, size - size_tail, block_size_in_bytes)\n            tail = tail..sub(message_part, #message_part + 1 - size_tail)\n            return partial\n         else\n            error(\"Adding more chunks is not allowed after receiving the result\", 2)\n         end\n      else\n         if tail then\n            -- append the following bits to the message: for usual SHA3: 011(0*)1, for SHAKE: 11111(0*)1\n            local gap_start = is_SHAKE and 31 or 6\n            tail = tail..(#tail + 1 == block_size_in_bytes and char(gap_start + 128) or char(gap_start)..string_rep(\"\\0\", (-2 - #tail) % block_size_in_bytes)..\"\\128\")\n            keccak_feed(lanes_lo, lanes_hi, tail, 0, #tail, block_size_in_bytes)\n            tail = nil\n\n            local lanes_used = 0\n            local total_lanes = floor(block_size_in_bytes \/ 8)\n            local qwords = {}\n            local function get_next_qwords_of_digest(qwords_qty)\n               -- returns not more than 'qwords_qty' qwords ('qwords_qty' might be non-integer)\n               -- doesn't go across keccak-buffer boundary\n               -- block_size_in_bytes is a multiple of 8, so, keccak-buffer contains integer number of qwords\n               if lanes_used >= total_lanes then\n                  keccak_feed(lanes_lo, lanes_hi, \"\\0\\0\\0\\0\\0\\0\\0\\0\", 0, 8, 8)\n                  lanes_used = 0\n               end\n               qwords_qty = floor(math_min(qwords_qty, total_lanes - lanes_used))\n               if hi_factor_keccak ~= 0 then\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX64(lanes_lo[lanes_used + j - 1 + lanes_index_base])\n                  end\n               else\n                  for j = 1, qwords_qty do\n                     qwords[j] = HEX(lanes_hi[lanes_used + j])..HEX(lanes_lo[lanes_used + j])\n                  end\n               end\n               lanes_used = lanes_used + qwords_qty\n               return\n                  gsub(table_concat(qwords, \"\", 1, qwords_qty), \"(..)(..)(..)(..)(..)(..)(..)(..)\", \"%8%7%6%5%4%3%2%1\"),\n                  qwords_qty * 8\n            end\n\n            local parts = {}      -- digest parts\n            local last_part, last_part_size = \"\", 0\n            local function get_next_part_of_digest(bytes_needed)\n               -- returns 'bytes_needed' bytes, for arbitrary integer 'bytes_needed'\n               bytes_needed = bytes_needed or 1\n               if bytes_needed <= last_part_size then\n                  last_part_size = last_part_size - bytes_needed\n                  local part_size_in_nibbles = bytes_needed * 2\n                  local result = sub(last_part, 1, part_size_in_nibbles)\n                  last_part = sub(last_part, part_size_in_nibbles + 1)\n                  return result\n               end\n               local parts_qty = 0\n               if last_part_size > 0 then\n                  parts_qty = 1\n                  parts[parts_qty] = last_part\n                  bytes_needed = bytes_needed - last_part_size\n               end\n               -- repeats until the length is enough\n               while bytes_needed >= 8 do\n                  local next_part, next_part_size = get_next_qwords_of_digest(bytes_needed \/ 8)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = next_part\n                  bytes_needed = bytes_needed - next_part_size\n               end\n               if bytes_needed > 0 then\n                  last_part, last_part_size = get_next_qwords_of_digest(1)\n                  parts_qty = parts_qty + 1\n                  parts[parts_qty] = get_next_part_of_digest(bytes_needed)\n               else\n                  last_part, last_part_size = \"\", 0\n               end\n               return table_concat(parts, \"\", 1, parts_qty)\n            end\n            if digest_size_in_bytes < 0 then\n               result = get_next_part_of_digest\n            else\n               result = get_next_part_of_digest(digest_size_in_bytes)\n            end\n         end\n         return result\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the SHA3 digest of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading\n      -- User should feed every chunk of input data as single argument to this function and finally get SHA3 digest by invoking this function without an argument\n      return partial\n   end\nend\n\n\nlocal hex2bin, bin2base64, base642bin\ndo\n   function hex2bin(hex_string)\n      return (gsub(hex_string, \"%x%x\",\n         function (hh)\n            return char(tonumber(hh, 16))\n         end\n      ))\n   end\n\n   local base64_symbols = {\n      ['+'] = 62, ['-'] = 62,  [62] = '+',[62] = '-',\n      ['\/'] = 63, ['_'] = 63,  [63] = '\/',[63] = '_',\n      ['='] = -1, ['.'] = -1,  [-1] = '='\n   }\n   local symbol_index = 0\n   for j, pair in ipairs{'AZ', 'az', '09'} do\n      for ascii = byte(pair), byte(pair, 2) do\n         local ch = char(ascii)\n         base64_symbols[ch] = symbol_index\n         base64_symbols[symbol_index] = ch\n         symbol_index = symbol_index + 1\n      end\n   end\n\n   function bin2base64(binary_string)\n      local result = {}\n      for pos = 1, #binary_string, 3 do\n         local c1, c2, c3, c4 = byte(sub(binary_string, pos, pos + 2)..'\\0', 1, -1)\n         result[#result + 1] =\n            base64_symbols[floor(c1 \/ 4)]\n            ..base64_symbols[c1 % 4 * 16 + floor(c2 \/ 16)]\n            ..base64_symbols[c3 and c2 % 16 * 4 + floor(c3 \/ 64) or -1]\n            ..base64_symbols[c4 and c3 % 64 or -1]\n      end\n      return table_concat(result)\n   end\n\n   function base642bin(base64_string)\n      local result, chars_qty = {}, 3\n      for pos, ch in gmatch(gsub(base64_string, '%s+', ''), '()(.)') do\n         local code = base64_symbols[ch]\n         if code < 0 then\n            chars_qty = chars_qty - 1\n            code = 0\n         end\n         local idx = pos % 4\n         if idx > 0 then\n            result[-idx] = code\n         else\n            local c1 = result[-1] * 4 + floor(result[-2] \/ 16)\n            local c2 = (result[-2] % 16) * 16 + floor(result[-3] \/ 4)\n            local c3 = (result[-3] % 4) * 64 + code\n            result[#result + 1] = sub(char(c1, c2, c3), 1, chars_qty)\n         end\n      end\n      return table_concat(result)\n   end\n\nend\n\nlocal block_size_for_HMAC  -- this table will be initialized at the end of the module\n\nlocal function pad_and_xor(str, result_length, byte_for_xor)\n   return gsub(str, \".\",\n      function(c)\n         return char(XOR_BYTE(byte(c), byte_for_xor))\n      end\n   )..string_rep(char(byte_for_xor), result_length - #str)\nend\n\nlocal function hmac(hash_func, key, message)\n\n   -- Create an instance (private objects for current calculation)\n   local block_size = block_size_for_HMAC[hash_func]\n   if not block_size then\n      error(\"Unknown hash function\", 2)\n   end\n   if #key > block_size then\n      key = hex2bin(hash_func(key))\n   end\n   local append = hash_func()(pad_and_xor(key, block_size, 0x36))\n   local result\n   local function partial(message_part)\n      if not message_part then\n         result = result or hash_func(pad_and_xor(key, block_size, 0x5C)..hex2bin(append()))\n         return result\n      elseif result then\n         error(\"Adding more chunks is not allowed after receiving the result\", 2)\n      else\n         append(message_part)\n         return partial\n      end\n   end\n\n   if message then\n      -- Actually perform calculations and return the HMAC of a message\n      return partial(message)()\n   else\n      -- Return function for chunk-by-chunk loading of a message\n      -- User should feed every chunk of the message as single argument to this function and finally get HMAC by invoking this function without an argument\n      return partial\n   end\n\nend\n\n\nsha = {\n   _VERSION     = \"9 (2020-05-10)\",\n   _DESCRIPTION = \"pura LUA Lib MD5, SHA-1, SHA-224, SHA-256, SHA-512\/224, SHA-512\/256, SHA-384, SHA-512, SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256, HMAC\",\n   _AUTHOR      = \"Egor Skriptunoff\",\n   _URL         = \"https:\/\/github.com\/Egor-Skriptunoff\/pure_lua_SHA\",\n   _LICENSE     = \"MIT (the same license as Lua itself)\",\n   md5        = md5,                                                                                                                   -- MD5\n   sha1       = sha1,                                                                                                                  -- SHA-1\n   -- SHA2 hash functions:\n   sha224     = function (message)                       return sha256ext(224, message)                                           end, -- SHA-224\n   sha256     = function (message)                       return sha256ext(256, message)                                           end, -- SHA-256\n   sha512_224 = function (message)                       return sha512ext(224, message)                                           end, -- SHA-512\/224\n   sha512_256 = function (message)                       return sha512ext(256, message)                                           end, -- SHA-512\/256\n   sha384     = function (message)                       return sha512ext(384, message)                                           end, -- SHA-384\n   sha512     = function (message)                       return sha512ext(512, message)                                           end, -- SHA-512\n   -- SHA3 hash functions:\n   sha3_224   = function (message)                       return keccak((1600 - 2 * 224) \/ 8, 224 \/ 8, false, message)             end, -- SHA3-224\n   sha3_256   = function (message)                       return keccak((1600 - 2 * 256) \/ 8, 256 \/ 8, false, message)             end, -- SHA3-256\n   sha3_384   = function (message)                       return keccak((1600 - 2 * 384) \/ 8, 384 \/ 8, false, message)             end, -- SHA3-384\n   sha3_512   = function (message)                       return keccak((1600 - 2 * 512) \/ 8, 512 \/ 8, false, message)             end, -- SHA3-512\n   shake128   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 128) \/ 8, digest_size_in_bytes, true, message) end, -- SHAKE128\n   shake256   = function (digest_size_in_bytes, message) return keccak((1600 - 2 * 256) \/ 8, digest_size_in_bytes, true, message) end, -- SHAKE256\n   -- misc utilities:\n   hmac       = hmac,       -- HMAC(hash_func, key, message) is applicable to any hash function from this module except SHAKE*\n   hex2bin    = hex2bin,    -- converts hexadecimal representation to binary string\n   base642bin = base642bin, -- converts base64 representation to binary string\n   bin2base64 = bin2base64, -- converts binary string to base64 representation\n}\n\nblock_size_for_HMAC = {\n   [sha.md5]        = 64,\n   [sha.sha1]       = 64,\n   [sha.sha224]     = 64,\n   [sha.sha256]     = 64,\n   [sha.sha512_224] = 128,\n   [sha.sha512_256] = 128,\n   [sha.sha384]     = 128,\n   [sha.sha512]     = 128,\n   [sha.sha3_224]   = (1600 - 2 * 224) \/ 8,\n   [sha.sha3_256]   = (1600 - 2 * 256) \/ 8,\n   [sha.sha3_384]   = (1600 - 2 * 384) \/ 8,\n   [sha.sha3_512]   = (1600 - 2 * 512) \/ 8,\n}\n--------------------------------------------------------------------------------------------------------------------------\n-- end of lib\n--------------------------------------------------------------------------------------------------------------------------","name":"sha2","type":"lua"},{"isOpen":false,"isMain":false,"content":"do\n  local VERSION = \"2.3\"\n\n  print(\"QwikAppChild library v\"..VERSION)\n  local childID = 'ChildID'\n  local classID = 'ClassName'\n  local callbacksID = 'uiCallbacks'\n  \n  function QuickApp:initChildDevices() end\n  QuickApp.children = {}\n  fibaro.debugFlags = fibaro.debugFlags or {}\n  fibaro.debugFlags.qwikchild = true\n  local fmt = string.format\n  local function ERRORF(f,...) fibaro.error(__TAG,fmt(f,...)) end\n  local function DEBUGF(f,...)\n    if  fibaro.debugFlags['qwikchild'] then fibaro.debug(__TAG,fmt(f,...)) end \n  end\n\n  -- arrayify table. Ensures that empty array is json encoded as \"[]\"\n  local function arrayify(t) \n    if type(t)=='table' then json.util.InitArray(t) end \n    return t\n  end\n  \n  local function traverse(o,f)\n    if type(o) == 'table' and o[1] then\n      for _,e in ipairs(o) do traverse(e,f) end\n    else f(o) end\n  end\n\n  -- Convert UI table to new uiView format\n  local function UI2NewUiView(UI)\n    local uiView = {}\n    for _,row in ipairs(UI) do\n      local urow = {\n        style = { weight = \"1.0\"},\n        type = \"horizontal\",\n      }\n      row = #row==0 and {row} or row\n      local weight = ({'1.0','0.5','0.25','0.33','0.20'})[#row]\n      local uels = {}\n      for _,el in ipairs(row) do\n        local name = el.button or el.slider or el.label or el.select or el.switch or el.multi\n        local typ = el.button and 'button' or el.slider and 'slider' or \n        el.label and 'label' or el.select and 'select' or el.switch and 'switch' or el.multi and 'multi'\n        local function mkBinding(name,action,fun,actionName)\n          local r = {\n            params = {\n              actionName = 'UIAction',\n              args = {action,name,'$event.value'}\n            },\n            type = \"deviceAction\"\n          }\n          return {r}\n        end \n        local uel = {\n          eventBinding = {\n            onReleased = (typ=='button' or typ=='switch') and mkBinding(name,\"onReleased\",typ=='switch' and \"$event.value\" or nil,el.onReleased) or nil,\n            onLongPressDown = (typ=='button' or typ=='switch') and mkBinding(name,\"onLongPressDown\",typ=='switch' and \"$event.value\" or nil,el.onLongPressDown) or nil,\n            onLongPressReleased = (typ=='button' or typ=='switch') and mkBinding(name,\"onLongPressReleased\",typ=='switch' and \"$event.value\" or nil,el.onLongPressReleased) or nil,\n            onToggled = (typ=='select' or typ=='multi') and mkBinding(name,\"onToggled\",\"$event.value\",el.onToggled) or nil,\n            onChanged = typ=='slider' and mkBinding(name,\"onChanged\",\"$event.value\",el.onChanged) or nil,\n          },\n          max = el.max,\n          min = el.min,\n          step = el.step,\n          name = el[typ],\n          options = arrayify(el.options),\n          values = arrayify(el.values) or ((typ=='select' or typ=='multi') and arrayify({})) or nil,\n          value = el.value,\n          style = { weight = weight},\n          type = typ=='multi' and 'select' or typ,\n          selectionType = (typ == 'multi' and 'multi') or (typ == 'select' and 'single') or nil,\n          text = el.text,\n          visible = true,\n        }\n        arrayify(uel.options)\n        arrayify(uel.values)\n        if not next(uel.eventBinding) then \n          uel.eventBinding = nil \n        end\n        uels[#uels+1] = uel\n      end\n      urow.components = uels\n      uiView[#uiView+1] = urow\n    end\n    return uiView\n  end\n  \n  -- Converts UI table to uiCallbacks table\n  local function UI2uiCallbacks(UI)\n    local cbs = {}\n    traverse(UI,\n    function(e)\n      local typ = e.button and 'button' or e.switch and 'switch' or e.slider and 'slider' or e.select and 'select' or e.multi and 'multi'\n      local name = e[typ]\n      if typ=='button' or typ=='switch' then\n        cbs[#cbs+1]={callback=e.onReleased or \"\",eventType='onReleased',name=name}\n        cbs[#cbs+1]={callback=e.onLongPressDown or \"\",eventType='onLongPressDown',name=name}\n        cbs[#cbs+1]={callback=e.onLongPressReleased or \"\",eventType='onLongPressReleased',name=name}\n      elseif typ == 'slider' then\n        cbs[#cbs+1]={callback=e.onChanged or \"\",eventType='onChanged',name=name}\n      elseif typ == 'select' then\n        cbs[#cbs+1]={callback=e.onToggled or \"\",eventType='onToggled',name=name}\n      elseif typ == 'multi' then\n        cbs[#cbs+1]={callback=e.onToggled or \"\",eventType='onToggled',name=name}\n      end\n    end)\n    return cbs\n  end\n  \n  -- Intercept UIEvents and call appropriate childQA\n  function QuickApp:setupUIhandler()\n    if not self.UIHandler then\n      function self:UIHandler(event)\n        local obj = self\n        if self.id ~= event.deviceId then obj = (self.childDevices or {})[event.deviceId] end\n        if not obj then return end\n        local elm,etyp = event.elementName, event.eventType\n        local cb = obj.uiCallbacks or {}\n        if obj[elm] then return obj:callAction(elm, event) end\n        local a = cb[elm][etyp]\n        local b = obj[a]\n        if cb[elm] and cb[elm][etyp] and obj[cb[elm][etyp]] then return obj:callAction(cb[elm][etyp], event) end\n        if obj[elm..\"Clicked\"] then return obj:callAction(elm..\"Clicked\", event) end\n        self:warning(\"UI callback for element:\", elm, \" not found-\")\n      end\n    end\n  end\n\n  -- Get\/Set internalStorage var for childQA\n  local function getVar(deviceId,key)\n    local res, stat = api.get(\"\/plugins\/\" .. deviceId .. \"\/variables\/\" .. key)\n    if stat ~= 200 then return nil end\n    return res.value\n  end\n  local function setVar(deviceId,key,val,hidden)\n    local data = { name = key, value = val, isHidden = hidden }\n    local _, stat = api.put(\"\/plugins\/\" .. deviceId .. \"\/variables\/\" .. key, data)\n    if stat > 206 then\n      local _, stat = api.post(\"\/plugins\/\" .. deviceId .. \"\/variables\", data)\n      return stat\n    end\n  end\n  \n  local UID = nil\n  class 'QwikAppChild'(QuickAppChild)\n  function QwikAppChild:__init(device)\n    QuickAppChild.__init(self, device)\n    local uid = UID or self:internalStorageGet(childID) or \"\"\n    self._className = self:internalStorageGet(classID) or \"\"\n    local uiCallbacks = self:internalStorageGet(callbacksID) or {}\n    self.properties.uiCallbacks = uiCallbacks\n    self._uid = uid\n    quickApp.children[uid]=self -- register child in QuickApp\n    self.uiCallbacks = {}\n    self:registerUICallbacks()\n    self._sid = tonumber(tostring(uid):match(\"(%d+)$\"))\n  end\n  \n  function QuickApp:_createChildDevice(uid, props, className)\n    __assert_type(props, 'table')\n    local store = props.store or {}\n    local room = props.room\n    props.room = nil\n    props.store = nil\n    props.parentId = self.id\n    table.insert(props.initialInterfaces, 'quickAppChild')\n    local p = props.initialProperties\n    if p.uiView and next(p.uiView)==nil then p.uiView = nil end\n    local uiCallbacks = props.initialProperties.uiCallbacks\n    if uiCallbacks and next(uiCallbacks) == nil then props.initialProperties.uiCallbacks = nil end\n    local device, res = api.post(\"\/plugins\/createChildDevice\", props)\n    assert(res == 200, \"Can't create child device \" .. tostring(res) .. \" - \" .. json.encode(props))\n    setVar(device.id,childID,uid,true)\n    setVar(device.id,classID,className,true)\n    if uiCallbacks then setVar(device.id,\"uiCallbacks\",uiCallbacks,true) end\n    for k,v in pairs(store) do \n      setVar(device.id,k,v,true)\n    end\n    if room then api.put(\"\/devices\/\"..device.id,{roomID=room}) end\n    local deviceClass = _G[className] or QuickAppChild\n    local child = deviceClass(device)\n    child.parent = self\n    self.childDevices[device.id] = child\n    return child\n  end\n  \n  local allChildren = {} \n\n  function QuickApp:createChild(uid,props,className,UI)\n    __assert_type(uid,'string')\n    __assert_type(className,'string')\n    quickApp = self\n    self:setupUIhandler()\n    if not next(allChildren) then\n      local devs = api.get(\"\/devices?parentId=\"..self.id) or {}\n      for _,dev in ipairs(devs) do\n        local uid = getVar(dev.id,childID) \n        if uid then allChildren[uid] = dev.id end\n      end\n    end\n    local id = allChildren[uid]\n    if id then\n      self.childDevices[id] = nil\n      self.children[uid] = nil\n      DEBUGF(\"Deleting existing child ID:%s, UID:'%s'\",id,uid)\n      api.delete(\"\/plugins\/removeChildDevice\/\" .. id)\n    end\n    props.initialProperties = props.properties or {}\n    props.initialInterfaces = props.interfaces or {}\n    props.properties = nil\n    props.interfaces = nil\n    if UI then\n      __assert_type(UI,'table')\n      local uiView = UI2NewUiView(UI)\n      local uiCallbacks = UI2uiCallbacks(UI)\n      props.initialProperties.uiView = uiView\n      props.initialProperties.uiCallbacks = uiCallbacks\n    end\n    UID = uid\n    local c = self:_createChildDevice(uid,props,className)\n    UID = nil\n    if not c then return end\n    DEBUGF(\"Created new child ID:%s, UID:'%s'\",c.id,uid)\n    return c\n  end\n  \n  function QuickApp:getChildrenUidMap()\n    local cdevs,map = api.get(\"\/devices?parentId=\"..self.id) or {},{}\n    for _,child in ipairs(cdevs) do\n      local uid = getVar(child.id,childID)\n      local className = getVar(child.id,classID)\n      if uid then map[uid]={id=child.id,className=className} end\n    end\n    return map\n  end\n\n  local function loadExisting(self,childrenDefs)\n    __assert_type(childrenDefs,'table')\n    self:setupUIhandler()\n    local cdevs,n,gerr = api.get(\"\/devices?parentId=\"..self.id) or {},0,nil -- Pick up all my children\n    for _,child in ipairs(cdevs) do\n      local uid = getVar(child.id,childID)\n      if uid then allChildren[uid] = child.id end\n      if uid and (childrenDefs==nil or childrenDefs[uid]) then\n        local className = getVar(child.id,classID) or \"\"\n        DEBUGF(\"Loading existing child UID:'%s'\",uid) \n        local stat,err = pcall(function()\n          local deviceClass = _G[className] or QuickAppChild\n          local childObject = deviceClass(child) -- Init\n          self.childDevices[child.id] = childObject\n          childObject.parent = self\n        end)\n        if not stat then\n          ERRORF(\"loadExistingChildren:%s child ID:%s, UID:'%s'\",err,child.id,uid)\n          gerr = err\n        else\n          n=n+1\n        end\n      end\n    end\n    return gerr,n\n  end\n  \n  function QuickApp:loadExistingChildren(childrenDefs)\n    quickApp = self\n    local stat,err = pcall(loadExisting,self,childrenDefs)\n    if not stat then ERRORF(\"loadExistingChildren: %s\",err) end\n  end\n\n  local function createMissing(self,childrenDefs)\n    local chs,k = {},0\n    -- Try to create children in uid alphabetical order\n    for uid,data in pairs(childrenDefs) do\n      local m = uid:sub(1,1)=='i' and 100 or 0; k = k + 1\n      chs[#chs+1]={uid=uid,id=m+tonumber(uid:match(\"(%d+)$\") or k),data=data}\n    end\n    table.sort(chs,function(a,b) return a.id<b.id end)\n\n    for _,ch in ipairs(chs) do\n      if not self.children[ch.uid] then -- not loaded yet\n        DEBUGF(\"Creating missing child UID:'%s'\",ch.uid)\n        local UI = ch.data.UI\n        local uid = ch.uid\n        local className = ch.data.className\n        local props = {\n          name = ch.data.name,\n          type = ch.data.type,\n          properties = ch.data.properties,\n          interfaces = ch.data.interfaces,\n          store = ch.data.store,\n          room = ch.data.room,\n        }\n        local child = self:createChild(uid,props,className,UI)\n      end\n    end\n  end\n  \n  function QuickApp:createMissingChildren(children)\n    __assert_type(children,'table')\n    local stat,err = pcall(createMissing,self,children)\n    if not stat then ERRORF(\"createMissingChildren: %s\",err) end\n  end\n\n  function QuickApp:removeUndefinedChildren(childrenDefs)\n    for uid,id in pairs(allChildren) do\n      if not childrenDefs[uid] then\n        DEBUGF(\"Deleting undefined child ID:%s, UID:%s\",id,uid)\n        api.delete(\"\/plugins\/removeChildDevice\/\" .. id)\n      end\n    end\n  end\n  \n  function QuickApp:initChildren(children)\n    if self:loadExistingChildren(children) then return end\n    self:createMissingChildren(children)\n    self:removeUndefinedChildren(children) -- Remove child devices not loaded\/created\n  end\n  \nend\n\n--[[\nUsage:\n  local children = {\n    i1 = {\n      name='ChildA',\n      type='com.fibaro.binarySensor',\n      properties={...},\n      interfaces={...},\n      store={<key>=<value>,...},\n      room=<roomID>,\n      UI=<UI>,\n    },\n    i2 = {\n      name='ChildB',\n      type='com.fibaro.binarySensor',\n      properties={...},\n      interfaces={...},\n      store={<key>=<value>,...},\n      room=<roomID>,\n      UI=<UI>,\n    },\n  }\n  \n  self:initChildren(children)\n  -- Will load existing children defined in table.\n  -- Will create missing children defined in table.\n  -- Will remove existing children not defined in table.\n\n  Alt.\n  self:loadExistingChildren()\n  -- Load existing children\n  self:createChild(uid,props,className,UI)\n  -- props = {\n  --   name = 'ChildA',\n  --   type = 'com.fibaro.binarySensor',\n  --   properties = {...},\n  --   interfaces = {...},\n  --   store = {<key>=<value>,...},\n  --   room = <roomID>,\n  -- }\n--]]","name":"QC","type":"lua"},{"isOpen":false,"isMain":false,"content":"---------------------------------------------------------------\n---  helper functions -----------------------------------------\n---------------------------------------------------------------\nlocal fmt = string.format\nfunction printf(...) print(fmt(...)) end\nfunction printc(col,f,...)\n  local str = fmt(f,...)\n  str = fmt(\"<font color=%s>%s<\/font>\",col,str)\n  print(str)\nend\n\nfunction table.copy(obj)\n  if type(obj) == 'table' then\n    local res = {}\n    for k, v in pairs(obj) do res[k] = table.copy(v) end\n    return res\n  else\n    return obj\n  end\nend\n\nfunction DEBUGF(tag,fmt,...)\n  if fibaro.debugFlags[tag] then\n    print(fmt:format(...))\n  end\nend\n\nfunction ERRORF(fmt,...)\n  fibaro.error(__TAG,fmt:format(...))\nend\n\nlocal IPaddress = nil\nfunction fibaro.getIPaddress(name)\n  if IPaddress then return IPaddress end\n  if fibaro._IPaddress then return fibaro._IPaddress\n  else\n    name = name or \".*\"\n    local networkdata = api.get(\"\/proxy?url=http:\/\/localhost:11112\/api\/settings\/network\")\n    for n,d in pairs(networkdata.networkConfig or {}) do\n      if n:match(name) and d.enabled then IPaddress = d.ipConfig.ip; return IPaddress end\n    end\n  end\nend\n\nfunction QuickApp:setupStorage()\n  local storage,qa = {},self\n  function storage:__index(key) return qa:internalStorageGet(key) end\n  function storage:__newindex(key,val)\n     if val == nil then qa:internalStorageRemove(key)\n     else qa:internalStorageSet(key,val,true) end\n   end\n  return setmetatable({},storage)\nend\n\nfunction urlencode(str)\n  if str then\n    str = str:gsub(\"\\n\", \"\\r\\n\")\n    str = str:gsub(\"([^%w %-%_%.%~])\", function(c)\n      return (\"%%%02X\"):format(string.byte(c))\n    end)\n    str = str:gsub(\" \", \"%%20\")\n  end\n  return str\t\nend\n\n---------------------------------------------------------------\n---  HTTP GET\/PUT ---------------------------------------------\n---------------------------------------------------------------\nfunction QuickApp:DGET(url,cb)\n  net.HTTPClient():request(Hub.api_base_url..url, {\n    options = {\n      method = 'GET',\n      headers = {\n        [\"Authorization\"] = \"Bearer \"..self.store.token\n      },\n      timeout = 10000,\n      checkCertificate = false,\n    },\n    success = function(response)\n      local data = json.decode(response.data)\n      cb(data)\n    end,\n    error = function(err)\n      ERRORF(\"Error get data: %s\", err)\n    end\n  })\nend\n\nfunction QuickApp:DPUT(url,data,cb)\n  url = Hub.api_base_url..url\n  data = json.encode(data)\n  local auth = \"Bearer \"..self.store.token\n  DEBUGF('http',\"PATCH: %s %s\",url,data or \"\")\n  net.HTTPClient():request(url, {\n    options = {\n      method = 'PATCH',\n      headers = {\n        [\"Content-Type\"] = \"application\/json\",\n        [\"Authorization\"] = auth,\n      },\n      data = data,\n      timeout = 10000,\n      checkCertificate = false,\n    },\n    success = function(response)\n      if response.status > 204 then\n        ERRORF(\"Error put data: %s\", response.status)\n        return\n      end\n      local data = {}\n      if response.data and response.data ~= \"\" then\n        data = json.decode(response.data)\n      end\n      if cb then cb(data) end\n    end,\n    error = function(err,s,g)\n      ERRORF(\"Error put data: %s %s\", err,data)\n    end\n  })\nend\n\nfunction QuickApp:DPOST(url,data,cb)\n  url = Hub.api_base_url..url\n  data = data and json.encode(data) or nil\n  local auth = \"Bearer \"..self.store.token\n  DEBUGF('http',\"POST: %s %s\",url,data or \"\")\n  net.HTTPClient():request(url, {\n    options = {\n      method = 'POST',\n      headers = {\n        [\"Content-Type\"] = \"application\/json\",\n        [\"Authorization\"] = auth,\n      },\n      data = data,\n      timeout = 10000,\n      checkCertificate = false,\n    },\n    success = function(response)\n      if response.status > 204 then\n        ERRORF(\"Error post data: %s\", response.status,data or \"\")\n        return\n      end\n      local data = {}\n      if response.data and response.data ~= \"\" then\n        data = json.decode(response.data)\n      end\n      if cb then cb(data) end\n    end,\n    error = function(err,s,g)\n      ERRORF(\"Error post data: %s %s\", err,data or \"\")\n    end\n  })\nend\n\nfunction QuickApp:DDEL(url,data,cb)\n  url = Hub.api_base_url..url\n  data = data and json.encode(data) or nil\n  local auth = \"Bearer \"..self.store.token\n  DEBUGF('http',\"DELETE: %s %s\",url,data or \"\")\n  net.HTTPClient():request(url, {\n    options = {\n      method = 'DELETE',\n      headers = {\n        [\"Content-Type\"] = \"application\/json\",\n        [\"Authorization\"] = auth,\n      },\n      data = data,\n      timeout = 10000,\n      checkCertificate = false,\n    },\n    success = function(response)\n      if response.status > 204 then\n        ERRORF(\"Error delete data: %s\", response.status,data or \"\")\n        return\n      end\n      local data = {}\n      if response.data and response.data ~= \"\" then\n        data = json.decode(response.data)\n      end\n      if cb then cb(data) end\n    end,\n    error = function(err,s,g)\n      ERRORF(\"Error delete data: %s %s\", err,data or \"\")\n    end\n  })\nend\n\nlocal function round(x) return math.floor(x+0.5) end\nfunction HSV2RGB(h,s,v)\n  s = s\/100.0\n  v = v\/100.0\n  local c = v*s\n  local x = c*(1.0-math.abs((h \/ 60.0) % 2 - 1))\n  local m = v-c\n  local rg,gg,bg\n\n  if h < 60 then\n    rg,gg,bg = c,x,0\n  elseif h < 120 then\n    rg,gg,bg = x,c,0\n  elseif h < 180 then\n    rg,gg,bg = 0,c,x\n  elseif h < 240 then\n    rg,gg,bg = 0,x,c\n  elseif h < 300 then\n    rg,gg,bg = x,0,c\n  elseif h < 360 then\n    rg,gg,bg = c,0,x\n  end\n\n  return round((rg+m)*255),round((gg+m)*255),round((bg+m)*255)\nend\n\nfunction RGB2HSV(r,g,b)\n  r,g,b = r\/255.0,g\/255.0,b\/255.0\n  local M = math.max(r,g,b)\n  local m = math.min(r,g,b)\n  local C = M-m\n\n  local h,s,v\n\n  if C == 0 then h = 0\n  elseif M == r then\n    h = ((g-b)\/C)%6\n  elseif M==g then\n    h = (b-r)\/C+2\n  else \n    h = (r-g)\/C+4\n  end\n  h = h*60\n  if h < 0 then h = h+360 end\n  v = M\n  if v == 0 then s = 0 else s = C\/v end\n  s = s*100\n  v = v*100\n  \n  return round(h),s,v\nend","name":"Lib","type":"lua"},{"isOpen":false,"isMain":false,"content":"---@diagnostic disable: undefined-global\n---------------------------------------------------------------\n--- Device classses (2) ------------------------------------------\n--- DirigeraDevice, base class for all devices\n--- Light, Lamps etc\n--- LightController, Remote controller with buttons\n--- Speaker, typically Sonos\n--- Gateway, The hub\n--- MotionSensor, usually combined with light sensor\n--- LightSensor, usually combined with motion sensor\n--- DoorSensor, magnetic sensor\n--- AirSensor, \n--- BinaySwitch, Outlet\n--- Speaker, Sonos players\n---------------------------------------------------------------\nDG = DG or { childs = {}}\nlocal fmt = string.format\nlocal function round(s) return math.floor(s+0.5) end\nlocal devices = { id={}, type={}, deviceType={}, name={} } \nDG.devices = devices\n\nlocal function dumpAttributes(id,a)\n  for k,v in pairs(a or {}) do\n    local d = DG.devices.id[id]\n    local name = d.attributes.customName\n    name = name and name ~= \"\" and name or \"<noname>\"\n    v = type(v)=='table' and json.encode(v) or v\n    DEBUGF('test',\"%s -%s: %s\",name,k,v)\n  end\nend\n\nfunction QuickApp:defineClasses()\n  \n  class 'DirigeraDevice'\n  function DirigeraDevice:__init(d) -- class for all devices\n    self.id = d.id\n    self.type = d.type\n    self.deviceType = d.deviceType\n    self.name = d.attributes.customName or \"<noname>\"\n    if self.name == \"\" then self.name = \"<noname>\" end\n    self.attributes = d.attributes\n    local r = {}\n    for _,v in ipairs(d.capabilities.canReceive or {}) do r[v] = true end\n    self.canReceive = r -- can-receieve map\n    self.capabilities = d.capabilities\n    if self.isReachable ~= d.isReachable then\n      self.isReachable = d.isReachable\n      printc('yellow',\"Init %s '%s' reachable: %s\",self.deviceType,self.name,d.isReachable)\n    end\n    dumpAttributes(d.id,d.attributes)\n  end\n  function DirigeraDevice:change(data)\n    if data.isReachable and self.isReachable ~= data.isReachable then\n      self.isReachable = data.isReachable\n      printc('yellow',\"Change '%s' reachable: %s\",self.name,data.isReachable)\n    end\n    dumpAttributes(data.id,data.attributes)\n    if self.child then self.child:updateProperty('dead',self.isReachable==false) end\n    if self.child then self:update(data) end\n  end\n  function DirigeraDevice:update(d) end -- Called when device is updated\n  function DirigeraDevice:created() \n    if self.child then \n      local manufacturer, model = self.attributes.manufacturer or \"\", self.attributes.model or \"\"\n      setTimeout(function() self.child:updateProperty('manufacturer',manufacturer) end,0)\n      self.child:updateProperty('model',model)\n      self.child:updateProperty('dead',self.isReachable==false)\n    end\n  end\n  \n  --- Device classes\n  class 'ChildDimmableLight'(QwikAppChild) -- Light that only have dimming capabilities\n  function ChildDimmableLight:__init(d) QwikAppChild.__init(self,d) end\n  class 'ChildDimmableLight'(QwikAppChild)\n  function ChildDimmableLight:__init(d) QwikAppChild.__init(self,d) end\n  function ChildDimmableLight:turnOn()\n    self:updateValue(100)\n    self.dev:turnOn()\n  end\n  function ChildDimmableLight:turnOff() \n    self:updateValue(0)\n    self.dev:turnOff() \n  end\n  function ChildDimmableLight:setValue(level) \n    print(\"SETLEVEL\",level)\n    self.dev:setLevel(level)\n    self.ignoreValue=true\n  end\n  function ChildDimmableLight:updateValue(level) --0..100\n    if not self.ignoreValue then\n      self:updateProperty('value',math.min(99,self.dev.lightLevel))\n      self:updateProperty('state',level>0)\n    end\n    self.ignoreValue=false\n  end\n  class 'ChildTempLight'(ChildDimmableLight) -- Light with temp control\n  function ChildTempLight:__init(d) ChildDimmableLight.__init(self,d) end\n  function ChildTempLight:setTemperature(temp) --0..100\n    print(json.encode(temp))\n    if type(temp)=='table' then temp = temp.values[1] end\n    self.dev:setTemperature(temp) \n  end \n  function ChildTempLight:updateTemperature(temp) --0..255\n    DEBUGF('color',\"TempLight updateTemperature called %s\",temp)\n    temp = round(temp\/255*100)\n    self:setVariable('temp',temp)\n    self:updateView('temp','value',tostring(temp))\n  end \n  \n  class 'ChildColorLight'(ChildTempLight) -- Light with color control\n  function ChildColorLight:__init(d) ChildTempLight.__init(self,d) end\n  function ChildColorLight:setColor(r,g,b,w)\n    local color = string.format(\"%d,%d,%d,%d\", r or 0, g or 0, b or 0, w or 0)\n    self:updateProperty(\"color\", color)\n    self.dev:setRGB(r,g,b,w) \n  end \n  function ChildColorLight:updateTemperature(temp) --0..255\n    DEBUGF('color',\"ColorLight updateTemp called %s\",temp)\n    local cc = self.properties.colorComponents \n    cc.warmWhite = temp\n    self:updateProperty(\"colorComponents\", cc)\n  end\n  function ChildColorLight:updateColor(r,g,b,w)\n    local color = string.format(\"%d,%d,%d,%d\", r or 0, g or 0, b or 0, w or 0)\n    DEBUGF('color',\"ColorLight updateColor called %s\",color)\n    self:updateProperty(\"color\", color)\n    local cc = self.properties.colorComponents \n    cc.red,cc.green,cc.blue,cc.white = r,g,b,cc.white and w or nil\n    self:updateProperty(\"colorComponents\", cc)\n  end\n  function ChildColorLight:setColorComponents(colorComponents) -- Called by HC3 UI\n    DEBUGF('color',\"setColorComponents called %s\",json.encode(colorComponents))\n    if colorComponents.warmWhite and not colorComponents.red then\n      DEBUGF('color',\"setColorComponents.temp\")\n      return self:setTemperature(colorComponents.warmWhite) -- 0..255\n    end\n    local cc = self.properties.colorComponents\n    local isColorChanged = false\n    for k,v in pairs(colorComponents) do\n      if cc[k] and cc[k] ~= v then cc[k] = v isColorChanged = true end\n    end\n    if isColorChanged == true then\n      self:updateProperty(\"colorComponents\", cc)\n      self:setColor(cc[\"red\"], cc[\"green\"], cc[\"blue\"], cc[\"white\"])\n    end\n  end\n  \n  class 'Light'(DirigeraDevice)\n  function Light:__init(d)\n    DirigeraDevice.__init(self,d)\n    if self.canReceive.colorHue and ChildColorLight then\n      DG.childs[self.id] = {\n        name = self.name, \n        type = 'com.fibaro.colorController',\n        className = 'ChildColorLight',\n        properties = {colorComponents = {red=0,green=0,blue=0,warmWhite=0}}\n      }\n    elseif self.canReceive.colorTemperature and ChildTempLight then\n      DG.childs[self.id] = {\n        name = self.name,\n        type = 'com.fibaro.multilevelSwitch',\n        className = 'ChildTempLight',\n        properties = {\n          uiView = json.decode('[{\"components\":[{\"name\":\"tempLabel\",\"style\":{\"weight\":\"0.5\"},\"text\":\"TEMPERATURE\",\"type\":\"label\",\"visible\":true},{\"eventBinding\":{\"onChanged\":[{\"params\":{\"actionName\":\"UIAction\",\"args\":[\"onChanged\",\"setTemperature\",\"$event.value\"]},\"type\":\"deviceAction\"}]},\"max\":\"100\",\"min\":\"0\",\"name\":\"tempSlider\",\"style\":{\"weight\":\"1.0\"},\"text\":\"\",\"type\":\"slider\",\"visible\":true}],\"style\":{\"weight\":\"1.0\"},\"type\":\"horizontal\"}]') \n        }\n      }\n    elseif self.canReceive.lightLevel and ChildDimmableLight then\n      DG.childs[self.id] = {\n        name = self.name,\n        type = 'com.fibaro.multilevelSwitch',\n        className = 'ChildDimmableLight',\n        properties = { uiView = {} }\n      } \n    else\n      ERRORF(\"Device %s can't recieve lightLevel, colorHue or colorTemperature\",self.name)\n    end\n  end\n  function Light:turnOn()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {isOn = true}}})\n  end\n  function Light:turnOff()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {isOn = false}}})\n  end\n  function Light:setLevel(level)\n    if not self.canReceive.lightLevel then\n      ERRORF(\"Device %s can't recieve lightLevel\",self.name)\n      return\n    end\n    if type(level)=='table' then level = tonumber(level.values[1]) end\n    level = level or self.lightLevel\n    if level > 100 then level = 100 elseif level < 1 then level = 1 end\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {lightLevel = level}}})\n  end\n  function Light:setRGB(r,g,b)\n    if not self.canReceive.colorHue then\n      ERRORF(\"Device %s can't recieve colorHue\",self.name)\n      return\n    end\n    local h,s,v = RGB2HSV(r,g,b)\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),\n    {{attributes = {\n      colorHue = h, colorSaturation = s\/100,\n      lightLevel = round(v),\n    }}})\n  end\n  function Light:setTemperature(temp) --0..255\n    local tempOrg = temp\n    if not self.canReceive.colorTemperature then\n      ERRORF(\"Device %s can't recieve colorTemperature\",self.name)\n      return\n    end\n    local attrs = self.attributes\n    local tint = attrs.colorTemperatureMin - attrs.colorTemperatureMax\n    temp = round(attrs.colorTemperatureMax + tint*temp\/255.0)\n    if temp > attrs.colorTemperatureMin then \n      temp = attrs.colorTemperatureMin\n    end\n    if temp < attrs.colorTemperatureMax then \n      temp = attrs.colorTemperatureMax\n    end\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {colorTemperature = temp}}})\n  end\n  \n  local filter = {colorMode=true,colorHue=true,colorSaturation=true,lightLevel=true,colorTemperature=true,isOn=true}\n  \n  function Light:update(d)\n    local a,n = {},0 -- Log interesting attributes\n    for k,v in pairs(d.attributes) do n=n+1; if filter[k] then a[k] = v end end\n    DEBUGF(\"color\",json.encode(a))\n    self.colorMode = d.attributes.colorMode or self.colorMode\n    if d.attributes.isOn ~= nil then self.isOn = d.attributes.isOn end\n    self.colorSaturation = d.attributes.colorSaturation or self.colorSaturation\n    self.colorHue = d.attributes.colorHue or self.colorHue\n    self.lightLevel = d.attributes.lightLevel or self.lightLevel\n    self.colorTemperature = d.attributes.colorTemperature or self.colorTemperature\n    if self.colorMode == 'temperature' then\n      if self.colorTemperature and self.child.setTemperature then\n        local attrs = self.attributes\n        if self.colorTemperature > attrs.colorTemperatureMin then\n          self.colorTemperature = attrs.colorTemperatureMin\n        end\n        if self.colorTemperature < attrs.colorTemperatureMax then\n          self.colorTemperature = attrs.colorTemperatureMax\n        end\n        local tnorm = self.colorTemperature - attrs.colorTemperatureMax\n        local tmax = attrs.colorTemperatureMin - attrs.colorTemperatureMax\n        local temp = round(tnorm\/tmax*255)\n        self.child:updateTemperature(temp)\n      end\n    elseif self.colorMode == 'color' then\n      if self.colorHue and color and self.child.updateColor then\n        local r,g,b = HSV2RGB(self.colorHue,100*self.colorSaturation,self.lightLevel)\n        self.child:updateColor(r,g,b,self.lightLevel or 0)\n      end\n    end\n    if self.isOn then\n      self.child:updateValue(self.lightLevel)\n    else\n      self.child:updateProperty('state',false)\n      self.child:updateProperty('value',0)\n      self.ignoreValue = false\n    end\n  end\n  \n  class 'LightController'\n  function LightController:__init(d)\n    DirigeraDevice.__init(self,d)\n  end\n  \n  class 'ChildSpeaker'(QwikAppChild)\n  function ChildSpeaker:__init(d) QwikAppChild.__init(self,d) end\n  function ChildSpeaker:play() self.dev:play() end\n  function ChildSpeaker:setMute(f) self.dev:setMute(f==0) end\n  function ChildSpeaker:stop() self.dev:stop() end\n  function ChildSpeaker:pause() self.dev:pause() end\n  function ChildSpeaker:next() self.dev:next() end\n  function ChildSpeaker:prev() self.dev:prev() end\n  function ChildSpeaker:setVolume(vol) self.dev:setVolume(vol) end\n  --playback: 'playbackPaused', \/\/ 'playbackPlaying'\n  class 'Speaker'(DirigeraDevice)\n  function Speaker:__init(d)\n    DirigeraDevice.__init(self,d)\n    DG.childs[self.id] = {\n      name = self.name,\n      type = 'com.fibaro.player',\n      className = 'ChildSpeaker'\n    }\n  end\n  function Speaker:play()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {playback = \"playbackPlaying\"}}})\n  end\n  function Speaker:stop()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {playback = \"playbackPaused\"}}})\n  end\n  function Speaker:pause()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {playback = \"playbackPaused\"}}})\n  end\n  function Speaker:setMute(v)\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {isMuted = v}}})\n  end\n  function Speaker:setVolume(v)\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {volume = v}}})\n  end\n  function Speaker:prev()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {playback = \"playbackPrevious\"}}})\n  end\n  function Speaker:next()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {playback = \"playbackNext\"}}})\n  end\n  local speakerStates = {\n    playbackPaused = 'paused',\n    playbackPlaying = 'playing',\n    playbackStopped = 'stopped',\n    playbackBuffering = 'buffering',\n    [\"\"] = 'unknown'\n  }\n  local function getIF(v,dflt) if v==nil then return dflt else return v end end\n  function Speaker:update(d)\n    local stat,res = pcall(function()\n      local attr = d.attributes\n      if attr.playbackAudio then\n        self.playbackAudio = attr.playbackAudio.playItem\n      end\n      --self.power = geattr.power or self.power\n      self.volume = getIF(attr.volume,self.volume)\n      self.muted = getIF(attr.isMuted,self.muted)\n      self.state = getIF(attr.playback,self.state)\n      if self.child then\n        local child = self.child\n        child:updateProperty('volume',self.volume)\n        child:updateProperty('mute',self.muted)\n        child:updateProperty('state',speakerStates[self.state])\n        if self.playbackAudio then\n          local song = self.playbackAudio\n          child:setVariable(\"artist\",song.artist or \"\")\n          child:setVariable(\"title\",song.title or \"\")\n          child:setVariable(\"album\",song.album or \"\")\n        end\n      end\n    end)\n    if not stat then \n      printc(\"red\",\"Speaker update error: %s\",res) \n    end\n  end\n  \n  class 'Gateway'(DirigeraDevice)\n  function Gateway:__init(d)\n    DirigeraDevice.__init(self,d)\n  end\n  \n  class 'ChildMotionSensor'(QwikAppChild)\n  function ChildMotionSensor:__init(d) QwikAppChild.__init(self,d) end\n  \n  class 'MotionSensor'(DirigeraDevice)\n  function MotionSensor:__init(d)\n    DirigeraDevice.__init(self,d)\n    DG.childs[self.id] = {\n      name = self.name,\n      type = 'com.fibaro.motionSensor',\n      className = 'ChildMotionSensor',\n      interfaces = {'battery'}\n    }\n  end\n  function MotionSensor:update(d)\n    if d.attributes.isDetected ~= nil then self.isDetected = d.attributes.isDetected end\n    if d.attributes.isOn ~= nil then self.isOn = d.attributes.isOn end\n    self.batteryPercentage = d.attributes.batteryPercentage\n    printc(\"yellow\",\"Motion isOn:%s isDetected:%s\",self.isOn,self.isDetected)\n    self.child:updateProperty('value',self.isDetected)\n    self.child:updateProperty('batteryLevel',self.batteryPercentage)\n  end\n  \n  class 'ChildLightSensor'(QwikAppChild)\n  function ChildLightSensor:__init(d) QwikAppChild.__init(self,d) end\n  \n  class 'LightSensor'(DirigeraDevice)\n  function LightSensor:__init(d)\n    DirigeraDevice.__init(self,d)\n    if self.name == \"\" then\n      local r = DG.childs[d.relationId..\"_1\"]\n      if r then self.name = r.name..\"(Temp)\" end\n    end\n    DG.childs[self.id] = {\n      name = self.name,\n      type = 'com.fibaro.lightSensor',\n      className = 'ChildLightSensor',\n      interfaces = {'battery'}\n    }\n  end\n  function LightSensor:update(d)\n    self.illuminance = d.attributes.illuminance or self.illuminance\n    self.batteryPercentage = d.attributes.batteryPercentage or self.batteryPercentage\n    self.child:updateProperty('value',self.illuminance)\n    local r = DG.devices.id[(d.relationId or \"\")..\"_1\"]\n    if r then \n      self.batteryPercentage = r.object.batteryPercentage\n    end\n    self.child:updateProperty('batteryLevel',self.batteryPercentage)\n  end\n  \n  class 'ChildDoorSensor'(QwikAppChild)\n  function ChildDoorSensor:__init(d) QwikAppChild.__init(self,d) end\n  \n  class 'DoorSensor'(DirigeraDevice)\n  function DoorSensor:__init(d)\n    DirigeraDevice.__init(self,d)\n    DG.childs[self.id] ={\n      name = self.name,\n      type = 'com.fibaro.doorSensor',\n      className = 'ChildDoorSensor',\n      interfaces = {'battery'}\n    }\n  end\n  function DoorSensor:update(d)\n    if d.attributes.isOpen ~= nil then self.isOpen = d.attributes.isOpen end\n    self.batteryPercentage = d.attributes.batteryPercentage or self.batteryPercentage\n    self.child:updateProperty('value',self.isOpen)\n    self.child:updateProperty('batteryLevel',self.batteryPercentage)\n  end\n  \n  class 'ChildWaterSensor'(QwikAppChild)\n  function ChildWaterSensor:__init(d) QwikAppChild.__init(self,d) end\n  \n  class 'WaterSensor'(DirigeraDevice)\n  function WaterSensor:__init(d)\n    DirigeraDevice.__init(self,d)\n    DG.childs[self.id] ={\n      name = self.name,\n      type = 'com.fibaro.waterSensor',\n      className = 'ChildWaterSensor',\n      interfaces = {'battery'}\n    }\n  end\n  function WaterSensor:update(d)\n    if d.attributes.waterLeakDetected ~= nil then self.waterLeakDetected = d.attributes.waterLeakDetected end\n    self.batteryPercentage = d.attributes.batteryPercentage or self.batteryPercentage\n    self.child:updateProperty('value',self.waterLeakDetected)\n    self.child:updateProperty('batteryLevel',self.batteryPercentage)\n  end\n  \n  class 'ChildPM25Sensor'(QwikAppChild)\n  function ChildPM25Sensor:__init(d) \n    QwikAppChild.__init(self,d) \n    setTimeout(function() self:updateProperty(\"unit\",\" µg\/m³\") end,0)\n    setTimeout(function() self:updateProperty(\"deviceIcon\",550) end,0)\n  end\n  class 'ChildVocSensor'(QwikAppChild)\n  function ChildVocSensor:__init(d) QwikAppChild.__init(self,d) \n    setTimeout(function() self:updateProperty(\"unit\",\" ppm\") end,0)\n    setTimeout(function() self:updateProperty(\"deviceIcon\",273) end,0)\n  end\n  class 'ChildTempSensor'(QwikAppChild)\n  function ChildTempSensor:__init(d) QwikAppChild.__init(self,d) end\n  class 'ChildHumiditySensor'(QwikAppChild)\n  function ChildHumiditySensor:__init(d) QwikAppChild.__init(self,d) end\n  \n  class 'AirSensor'(DirigeraDevice)\n  function AirSensor:__init(d)\n    DirigeraDevice.__init(self,d)\n    local manufacturer, model = d.attributes.manufacturer or \"\", d.attributes.model or \"\"\n    DG.childs[self.id..\"_pm25\"] = {\n      name = self.name..\"(PM25)\",\n      type = 'com.fibaro.multilevelSensor',\n      properties = {unit = \" µg\/m³\", manufacturer = manufacturer, model = model},\n      className = 'ChildPM25Sensor'\n    }\n    DG.childs[self.id..\"_voc\"] = {\n      name = self.name..\"(tVOC)\",\n      type = 'com.fibaro.multilevelSensor',\n      properties = {unit = \" ppm\", manufacturer = manufacturer, model = model},\n      className = 'ChildVocSensor'\n    }\n    DG.childs[self.id] = {\n      name = self.name..\"(Humidity)\",\n      type = 'com.fibaro.humiditySensor',\n      properties = {manufacturer = manufacturer, model = model},\n      className = 'ChildHumiditySensor'\n    }\n    DG.childs[self.id..\"_temp\"] = {\n      name = self.name..\"(Temp)\",\n      type = 'com.fibaro.temperatureSensor',\n      \n      className = 'ChildTempSensor'\n    }\n  end\n  function AirSensor:update(d)\n    self.currentRH = d.attributes.currentRH or self.currentRH\n    self.currentPM25 = d.attributes.currentPM25 or self.currentPM25\n    self.vocIndex = d.attributes.vocIndex or self.vocIndex\n    self.currentTemperature = d.attributes.currentTemperature or self.currentTemperature\n    local PM = quickApp.children[self.id..\"_pm25\"]\n    if PM then PM:updateProperty('value',self.currentPM25) end\n    local RH = quickApp.children[self.id]\n    if RH then RH:updateProperty('value',self.currentRH) end\n    local TEMP = quickApp.children[self.id..\"_temp\"]\n    if TEMP then TEMP:updateProperty('value',self.currentTemperature) end\n    local VOC = quickApp.children[self.id..\"_voc\"]\n    if VOC then VOC:updateProperty('value',self.vocIndex) end\n  end\n  \n  class 'ChildBinarySwitch'(QwikAppChild)\n  function ChildBinarySwitch:__init(d)\n    QwikAppChild.__init(self,d)\n  end\n  function ChildBinarySwitch:turnOn() self.dev:turnOn() end\n  function ChildBinarySwitch:turnOff() self.dev:turnOff() end\n  \n  class 'BinarySwitch'(DirigeraDevice)\n  function BinarySwitch:__init(d)\n    DirigeraDevice.__init(self,d)\n    local interfaces = {}\n    if d.attributes.totalEnergyConsumed then \n      table.insert(interfaces,'energy') \n    end\n    if d.attributes.currentActivePower then \n      table.insert(interfaces,'power') \n    end\n    if #interfaces == 0 then interfaces = nil end\n    DG.childs[self.id] = {\n      name = self.name,\n      type = 'com.fibaro.binarySwitch',\n      className = 'ChildBinarySwitch',\n      interfaces = interfaces\n    }\n  end\n  function BinarySwitch:turnOn()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {isOn = true}}}) \n  end\n  function BinarySwitch:turnOff()\n    quickApp:DPUT(fmt(\"\/devices\/%s\",self.id),{{attributes = {isOn = false}}})\n  end\n  function BinarySwitch:update(data)\n    if not self.child then return end\n    self.currentAmps = data.attributes.currentAmps or self.currentAmps\n    self.currentVoltage = data.attributes.currentVoltage or self.currentVoltage\n    self.currentActivePower = data.attributes.currentActivePower or self.currentActivePower\n    self.totalEnergyConsumed = data.attributes.totalEnergyConsumed or self.totalEnergyConsumed\n    if data.attributes.isOn ~= nil then self.isOn = data.attributes.isOn end\n    self.child:updateProperty('value',self.isOn)\n    if self.currentActivePower then\n      self.child:updateProperty('power',self.currentActivePower)\n    end\n    if self.totalEnergyConsumed then\n      self.child:updateProperty('energy',self.totalEnergyConsumed)\n    end\n  end\n  \n  ---------------\n  local function NoDevice(d)\n    print(\"Device not implemented: \",d.deviceType)\n  end\n  local deviceTypeMap = {\n    [\"light\"] = Light,\n    [\"lightController\"] = LightController,\n    [\"speaker\"] = Speaker,\n    [\"gateway\"] = Gateway,\n    [\"motionSensor\"] = MotionSensor,\n    [\"lightSensor\"] = LightSensor,\n    [\"openCloseSensor\"] = DoorSensor,\n    [\"environmentSensor\"] = AirSensor,\n    [\"outlet\"] = BinarySwitch,\n    ['blinds'] = NoDevice, --Blinds,\n    ['waterSensor'] = NoDevice, --WaterSensor\n    ['airPurifier'] = NoDevice, -- AirPurifier\n  }\n  \n  function DG:addDevice(d)\n    devices.id[d.id] = d\n    devices.type[d.type] = d\n    devices.deviceType[d.deviceType] = d\n    devices.name[d.attributes.customName] = d\n    d.object = (deviceTypeMap[d.deviceType] or NoDevice)(d)\n  end\n  \n  local scenes = {}\n  function DG:addScene(d)\n    scenes[d.info.name] = d\n  end\n  \n  function QuickApp:scene(name,trigger)\n    local scene = scenes[name]\n    if not scene then ERRORF(\"Scene %s not found\",name) return end\n    if trigger == false then\n      self:DPOST(fmt(\"\/scenes\/%s\/undo\",scene.id))\n    else\n      self:DPOST(fmt(\"\/scenes\/%s\/trigger\",scene.id))\n    end\n  end\n  \n  function QuickApp:createScene(name,icon,sceneType,triggers,actions)\n    ---Creates a new scene.\n    --- Note:\n    ---To create an empty scene leave actions and triggers None.\n    -- Args:\n    --     info (Info): Name & Icon\n    --     type (SceneType): typically USER_SCENE\n    --     triggers (List[Trigger]): Triggers for the Scene (An app trigger will be created automatically)\n    --     actions (List[Action]): Actions that will be run on Trigger\n    \n    -- Returns:\n    --     Scene: Returns the newly created scene.\n    local triggerList = json.util.InitArray({})\n    if triggers then\n      for _,x in ipairs(triggers) do triggerList[#triggerList+1] = json.encode(x) end\n      \n    end\n    local actionList = json.util.InitArray({})\n    if actions then\n      for _,x in ipairs(actions) do actionList[#actionList+1] = json.encode(x) end\n    end\n    local data = {\n      info = {name=name,icon=icon or \"scenesSnowflake\"},\n      type =  sceneType or \"userScene\",\n      triggers = triggerList,\n      actions = actionList,\n    }\n    local d = json.encode(data)\n    self:DPOST(\"\/scenes\/\",data,function(d)\n      print(json.encode(d))\n    end)\n  end\n  \n  function DG:linkDevices() \n    for _,d in pairs(devices.id) do\n      local child = quickApp.children[d.id]\n      if child then \n        d.object.child = child\n        child.dev = d.object\n        d.object:update(d)\n        d.object:created()\n      end\n    end\n  end\n  \nend","name":"Devices","type":"lua"},{"isOpen":false,"isMain":false,"content":"---------------------------------------------------------------\n---  Authorization --------------------------------------------\n---------------------------------------------------------------\nlocal fmt = string.format\n\nlocal function codeChallenge(codeVerifier)\n  local hash = sha.sha256(codeVerifier)\n  local binhash = sha.hex2bin(hash)\n  local base64hash = sha.bin2base64(binhash)\n  return base64hash\nend\n\nlocal function getToken(IP, code, codeVerifier, cb)\n  local data = \n  \"code=\"..urlencode(code)\n  ..\"&name=\"..urlencode(\"127.0.0.1\") ---fibaro.getIPaddress()\n  ..\"&grant_type=authorization_code\"\n  ..\"&code_verifier=\"..urlencode(codeVerifier)\n  local headers = { \n    ['Content-Type'] = \"application\/x-www-form-urlencoded;charset=UTF-8\",\n    --['Content-Length'] = #data\n    --[\"Accept\"] = \"application\/json\"\n  }\n  local tokenURL = fmt(\"https:\/\/%s:8443\/v1\/oauth\/token\",IP)\n  -- print(code)\n  -- print(data)\n  net.HTTPClient():request(tokenURL, {\n    options = {\n      method = 'POST',\n      headers = headers,\n      data = data,\n      timeout = 10000,\n      checkCertificate = false\n    },\n    success = function(response)\n      local stat,res = pcall(json.decode,response.data)\n      if not stat then\n        ERRORF(\"Error get token: %s \", json.encode(response))\n        return\n      end\n      local data = res\n      cb(data.access_token)\n    end,\n    error = function(err)\n      ERRORF(\"Error get token: %s\", err)\n    end\n  })\nend\n\nlocal function sendChallenge(IP, codeVerifier)\n  local authUrl = fmt(\"https:\/\/%s:8443\/v1\/oauth\/authorize\",IP)\n  local params = \"?audience=homesmart.local&response_type=code&code_challenge=%s&code_challenge_method=S256\"\n  local cc = codeChallenge(codeVerifier)\n  cc = cc:sub(1, -2)\n  params = fmt(params, cc)\n  Hub.lastRequest = nil\n  net.HTTPClient():request(authUrl..params, {\n    options = {\n      method = 'GET',\n      headers = {\n      },\n      checkCertificate = false,\n      timeout = 10000\n    },\n    success = function(response)\n      local data = json.decode(response.data)\n      if data == nil then \n        ERRORF(\"Error requesting token: %s\", json.encode(response))\n        return\n      end\n      print(\"Press the action button on the bottom of the Dirigera hub, then press QA button 'Get token'' ...\" )\n      Hub.lastRequest = { IP=IP, codeVerifier=codeVerifier, code=data.code}\n      --getToken(IP, data.code, codeVerifier, cb)\n    end,\n    error = function(err)\n      ERRORF(\"Error requesting token: %s\", err)\n    end\n  })\nend\n\nfunction QuickApp:requestToken()\n  local randomCode = {}\n  local chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~\"\n  for i=1,128 do\n    local n = math.random(1, #chars)\n    randomCode[#randomCode+1] = chars:sub(n, n)\n  end\n  local codeVerifier = table.concat(randomCode)\n  DEBUGF('test',\"%s %s\",#codeVerifier,codeVerifier)\n  sendChallenge(Hub.IP, codeVerifier)\nend\n\nfunction QuickApp:getToken()\n  local lastRequest = Hub.lastRequest\n  if not lastRequest then\n    ERRORF(\"No last request\")\n    return\n  end\n  getToken(Hub.lastRequest.IP, lastRequest.code, lastRequest.codeVerifier, function(token)\n    DEBUGF('test',\"Token %s\",token)\n    self.store.token = token\n    plugin.restart()\n  end)\nend\n","name":"Auth","type":"lua"},{"isOpen":false,"isMain":true,"content":"--[[\nDirigera connectivity for the Fibaro Home Center 3\nCopyright (c) 2021 Jan Gabrielsson\nEmail: jan@gabrielsson.com\nGNU GENERAL PUBLIC LICENSE\nVersion 3, 29 June 2007\n\nCopyright (C) 2007 Free Software Foundation, Inc. <https:\/\/fsf.org\/>\nEveryone is permitted to copy and distribute verbatim copies\nof this license document, but changing it is not allowed.\n\nSHA 256 library from @tinman\n--]]\n_DEVELOP=\"..\/hc3emu\"\nif require and not QuickApp then require(\"hc3emu\") end\n--%%name=Dirigera\n--%% id=1782\n--%%uid=UPD896846032517893\n--%%save=Dirigera.fqa\n--%%proxy=DirigeraProxy\n--%%type=com.fibaro.deviceController\n--%%var=debug:\"test=false,http=true,color=true\"\n\n--%%u={label=\"titelLabel\",text=\"Dirigera\"}\n--%%u={{button=\"b1\",text=\"Request token\",visible=true,onReleased=\"requestToken\"},{button=\"b2\",text=\"Get token\",visible=true,onReleased=\"getToken\"}}\n--%%u={{button=\"b3\",text=\"List device info\",visible=true,onReleased=\"listDeviceInfo\"},{button=\"b4\",text=\"Restart\",visible=true,onReleased=\"restartQA\"}}\n--%%u={multi=\"select_ID_4\",text=\"Devices\",visible=true,onToggled=\"selectDevices\",options={}}\n\n--%%file=$hc3emu.sha2,sha2;\n--%%file=$hc3emu.QwikChild,QC;\n--%%file=Lib.lua,Lib;\n--%%file=Devices.lua,Devices;\n--%%file=Auth.lua,Auth;\n--%%var=IP:\"192.168.1.165\"\n\n--%%debug=refresh:false\n\nlocal VERSION = \"1.0\"\nDG = DG or { childs = {}}\n\nlocal TOKEN = \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjAxNTRmZDM0MTA1MzMxYmMxNjM5MDAxZTQ3OTJjMDUxZWZiNjc0YjI1YmQ1YTRhZGYzMTI1MTFkYzI4YzFkMDgifQ.eyJpc3MiOiJkN2ZiNDNjZi1lOTgxLTQxNzUtOTliMi1iYTdhYjM3ZTY5NmQiLCJ0eXBlIjoiYWNjZXNzIiwiYXVkIjoiaG9tZXNtYXJ0LmxvY2FsIiwic3ViIjoiNTI5ZDA3NzQtZTgxNi00ZGI0LTllYmUtYmNjMDVhYTljYTNjIiwiaWF0IjoxNzI4NTQ5NzE0LCJleHAiOjIwNDQxMjU3MTR9.25sVue2TyZsdx2ZobazMFO3oiIstkcL-nsAuq_kg257OOmp7OLKJEffdAHyBcRXHDM4T_S3tYmdt71jPIW17Sw\"\n---------------------------------------------------------------\n---  local variables ------------------------------------------\n---------------------------------------------------------------\nHub = {\n  IP = nil,\n  port = \"8443\",\n  api_version = \"v1\",\n  api_base_url = nil,\n  lastRequest = nil\n}\nlocal fmt = string.format\nfibaro.debugFlags = fibaro.debugFlags or { }\n\nlocal MessageHandler = {}\nfunction MessageHandler.deviceStateChanged(data)\n  local d = DG.devices.id[data.data.id]\n  if d and d.object then d.object:change(data.data) end\nend\nfunction MessageHandler.sceneUpdated(data)\n  print(\"SCENE\",data.data.info.name)\nend\n\nfunction QuickApp:restartQA()\n  printc(\"red\",\"Restarting QuickApp...\")\n  plugin.restart()\nend\n\nfunction QuickApp:listDeviceInfo()\n  local pr = function(...) printc(\"yellow\",...) end\n  for _,dev in pairs(DG.devices.id) do\n    local d = dev.object\n    local a = d.attributes\n    pr(\"%s '%s' %s\",d.deviceType,d.name,d.id)\n    pr(\"model:%s\",a.model or \"\")\n    pr(\"manufacturer:%s\",a.manufacturer or \"\")\n    pr(\"firmware:%s\",a.firmwareVersion or \"\")\n    pr(\"hardware:%s\",a.hardwareVersion or \"\")\n    pr(\"----------------------------------\")\n  end\nend\n\nfunction QuickApp:removeChildren()\n  for id,_ in pairs(self.childDevices or {}) do self:removeChildDevice(id) end\nend\n\nfunction QuickApp:listen()\n  DEBUGF('test',\"Websocket connect\")\n  local url = fmt(\"wss:\/\/%s:%s\/%s\",Hub.IP,Hub.port,Hub.api_version)\n  local headers = {\n    [\"Authorization\"] = \"Bearer \"..self.store.token\n  }\n  local function handleConnected()\n    DEBUGF('test',\"Connected\")\n  end\n  local function handleDisconnected()\n    DEBUGF('test',\"Disconnected\")\n    self:warning(\"Disconnected - will restart in 5s\")\n    setTimeout(function()\n      plugin.restart()\n    end,5000)\n  end\n  local function handleError(err)\n    ERRORF(\"Error: %s\", err)\n  end\n  local function handleDataReceived(data)\n    --print(data)\n    data = json.decode(data)\n    local handler  = MessageHandler[data.type or \"\"]\n    if handler then handler(data) \n    else\n      DEBUGF('test',\"Unknown message type: %s\",data.type)\n    end\n  end\n  self.sock = net.WebSocketClientTls()\n  self.sock:addEventListener(\"connected\", handleConnected)\n  self.sock:addEventListener(\"disconnected\", handleDisconnected)\n  self.sock:addEventListener(\"error\", handleError)\n  self.sock:addEventListener(\"dataReceived\", handleDataReceived) \n  \n  DEBUGF('test',\"Connect: %s\",url)\n  self.sock:connect(url, headers)\nend\n\nfunction QuickApp:onInit()\n  print(\"Dirigera version:\",VERSION)\n  self:updateView(\"titelLabel\",\"text\",\"Dirigera v\"..VERSION)\n  function self.initChildDevices() end\n  local dbgs = self:getVariable(\"debug\")\n  dbgs:gsub(\"(%w+)=([FfAaLlSsEeTtRrUu]+)\",function(f,v) \n    v = v:lower()\n    if v == \"true\" then fibaro.debugFlags[f] = true elseif v == \"false\" then fibaro.debugFlags[f] = false end\n  end)\n  self.store = self:setupStorage()\n  Hub.IP = self:getVariable(\"IP\")\n  if Hub.IP == \"\" then\n    self:warning(\"Please set IP address of Dirigera\")\n    return\n  end\n  Hub.api_base_url = fmt(\"https:\/\/%s:%s\/%s\",Hub.IP,Hub.port,Hub.api_version)\n  self:defineClasses()\n  if TOKEN then self.store.token = TOKEN end\n  if self.store.token == nil then\n    print(\"Please Request & Get token...\")\n    print(\"Start by pressing QA button 'Request token'\")\n    return\n  else\n    print(\"Your TOKEN :\",self.store.token)\n  end\n  local devices = self.store.devices\n  if devices == nil then\n    local chs = api.get(\"\/devices?parentId=\"..self.id) or {}\n    devices = {}\n    for _,child in ipairs(chs) do devices[child.id] = true end\n  end\n  self.store.devices = devices\n  self:DGET(\"\/devices\",function(ddata)\n    local oldDevices = table.copy(devices)\n    devices = {}\n    for _,d in ipairs(ddata) do\n      devices[d.id] = oldDevices[d.id] or false\n      DG:addDevice(d)\n      print(d.id)\n    end\n    self.store.devices = devices\n    self:populateDeviceSelector()\n    self:DGET(\"\/scenes\",function(sdata)\n      for _,d in ipairs(sdata) do\n        DG:addScene(d)\n      end\n      local function filter(ds,df)\n        local res = {}\n        for id,d in pairs(ds) do \n          local match = id:match(\"(.*_.*)_\") or id\n          if df[match] then res[id] = d end \n        end\n        return res\n      end\n      self:DGET(\"\/home\",function(hdata)\n        local hub = DG.devices.type['gateway']\n        local attr = hub.attributes\n        printf(\"Gateway: %s\",attr.customName or \"\")\n        printf(\"model:%s\",attr.model)\n        printf(\"firmware:%s\",attr.firmwareVersion)\n        printf(\"hardware:%s\",attr.hardwareVersion)  \n        quickApp:initChildren(filter(DG.childs,devices))\n        DG:linkDevices()\n        quickApp:listen()\n      end)\n    end)\n  end)\nend\n\nfunction QuickApp:populateDeviceSelector()\n  local options = {}\n  local values = {}\n  local devices = self.store.devices\n  for id,d in pairs(DG.childs) do\n    local dev = DG.devices.id[id]\n    if dev then \n      local name = d.name or \"\"\n      if name == \"\" then name = \"<noname>\" end\n      name = string.format(\"%s (%s)\",name,dev.attributes.model)\n      local i = {text=name,type=\"option\",value=id}\n      table.insert(options,i)\n      if devices[id] then table.insert(values,id) end\n    end\n  end\n  table.sort(options,function(a,b) return a.text < b.text end)\n  self:updateView(\"select_ID_4\",\"options\",options)\n  self:updateView(\"select_ID_4\",\"selectedItems\",values)\nend\n\nfunction QuickApp:selectDevices(data)\n  local devices = self.store.devices\n  for id,_ in pairs(devices) do devices[id] = false end\n  for _,d in pairs(data.values[1]) do\n    devices[d] = true\n  end\n  self.store.devices = devices\nend\n\n-- quickApp:post(function() quickApp:scene(\"Tända sovrum\",true) end,3000)\n-- quickApp:post(function() quickApp:scene(\"Tända sovrum\",false) end,6000)\n--quickApp:createScene(\"Test42\")\n--quickApp:DDEL(\"\/scenes\/716340ae-4124-4445-bac7-32a2e0bb1a9e\")\n--quickApp:post(function() DG.devices.name['Led sovrum'].object:turnOn() end,3000)\n--quickApp:post(function() DG.devices.name['Led sovrum'].object:turnOff() end,6000)\n","name":"main","type":"lua"}],"initialInterfaces":["quickApp"],"name":"DirigeraProxy","initialProperties":{"manufacturer":"","uiView":[{"components":[{"text":"Dirigera","style":{"weight":"1.0"},"name":"titelLabel","visible":true,"type":"label"}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"Request token","visible":true,"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","b1"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","b1"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","b1"]},"type":"deviceAction"}]},"name":"b1","style":{"weight":"0.5"},"type":"button"},{"text":"Get token","visible":true,"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","b2"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","b2"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","b2"]},"type":"deviceAction"}]},"name":"b2","style":{"weight":"0.5"},"type":"button"}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"text":"List device info","visible":true,"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","b3"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","b3"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","b3"]},"type":"deviceAction"}]},"name":"b3","style":{"weight":"0.5"},"type":"button"},{"text":"Restart","visible":true,"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","b4"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","b4"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","b4"]},"type":"deviceAction"}]},"name":"b4","style":{"weight":"0.5"},"type":"button"}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"values":{},"text":"Devices","options":{},"name":"select_ID_4","type":"select","visible":true,"eventBinding":{"onToggled":[{"params":{"actionName":"UIAction","args":["onToggled","select_ID_4","$event.value"]},"type":"deviceAction"}]},"selectionType":"multi","style":{"weight":"1.0"}}],"style":{"weight":"1.0"},"type":"horizontal"}],"typeTemplateInitialized":true,"quickAppVariables":[{"value":"test=false,http=true,color=true","name":"debug"},{"value":"192.168.1.165","name":"IP"}],"useEmbededView":true,"uiCallbacks":[{"callback":"requestToken","eventType":"onReleased","name":"b1"},{"callback":"","eventType":"onLongPressDown","name":"b1"},{"callback":"","eventType":"onLongPressReleased","name":"b1"},{"callback":"getToken","eventType":"onReleased","name":"b2"},{"callback":"","eventType":"onLongPressDown","name":"b2"},{"callback":"","eventType":"onLongPressReleased","name":"b2"},{"callback":"listDeviceInfo","eventType":"onReleased","name":"b3"},{"callback":"","eventType":"onLongPressDown","name":"b3"},{"callback":"","eventType":"onLongPressReleased","name":"b3"},{"callback":"restartQA","eventType":"onReleased","name":"b4"},{"callback":"","eventType":"onLongPressDown","name":"b4"},{"callback":"","eventType":"onLongPressReleased","name":"b4"},{"callback":"selectDevices","eventType":"onToggled","name":"select_ID_4"}],"quickAppUuid":"","buildNumber":1,"useUiView":true,"supportedDeviceRoles":["Other"],"model":"","viewLayout":{"$jason":{"body":{"header":{"style":{"height":"200"},"title":"quickApp_device_52"},"sections":{"items":[{"components":[{"text":"Dirigera","style":{"weight":"1.2"},"name":"titelLabel","visible":true,"type":"label"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"text":"Request token","style":{"weight":"0.50"},"name":"b1","visible":true,"type":"button"},{"text":"Get token","style":{"weight":"0.50"},"name":"b2","visible":true,"type":"button"}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"components":[{"text":"List device info","style":{"weight":"0.50"},"name":"b3","visible":true,"type":"button"},{"text":"Restart","style":{"weight":"0.50"},"name":"b4","visible":true,"type":"button"}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"visible":true,"name":"select_ID_4","values":{},"text":"Devices","options":{},"style":{"weight":"1.2"},"selectionType":"multi","type":"select"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_52"}}},"userDescription":"","apiVersion":"1.3","deviceRole":"Other"},"type":"com.fibaro.deviceController"}